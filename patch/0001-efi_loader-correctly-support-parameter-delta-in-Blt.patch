From 3a1acdf59749fd3b79ca0b725b59b8ce699596b5 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Wed, 14 Mar 2018 18:42:06 +0100
Subject: [PATCH 1/1] efi_loader: correctly support parameter delta in Blt

In the Blt service of the EFI_GRAPHICS_OUTPUT_PROTOCOL the parameter delta
is measured in bytes and not in pixels.

The corrected coding only supports 4 byte aligned buffers. The UEFI
specification does not explicitely require this.

The corresponding unit test is corrected, too.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_gop.c               | 32 +++++++++++++++++++++++++++-----
 lib/efi_selftest/efi_selftest_bitblt.c |  2 +-
 2 files changed, 28 insertions(+), 6 deletions(-)

diff --git a/lib/efi_loader/efi_gop.c b/lib/efi_loader/efi_gop.c
index 154f306540..ac92109f16 100644
--- a/lib/efi_loader/efi_gop.c
+++ b/lib/efi_loader/efi_gop.c
@@ -77,6 +77,24 @@ static inline u16 efi_blt_col_to_vid16(struct efi_gop_pixel *blt)
 	       (u16)(blt->blue  >> 3);
 }
 
+/*
+ * Copy rectangle.
+ *
+ * This function implements the Blt service of the EFI_GRAPHICS_OUTPUT_PROTOCOL.
+ * See the Unified Extensible Firmware Interface (UEFI) specification for
+ * details.
+ *
+ * @this:	EFI_GRAPHICS_OUTPUT_PROTOCOL
+ * @buffer:	pixel buffer
+ * @sx:		source x-coordinate
+ * @sy:		source y-coordinate
+ * @dx:		destination x-coordinate
+ * @dy:		destination y-coordinate
+ * @width:	width of rectangle
+ * @height:	height of rectangle
+ * @delta:	length in bytes of a line in the pixel buffer (optional)
+ * @return:	status code
+ */
 efi_status_t EFIAPI gop_blt(struct efi_gop *this, struct efi_gop_pixel *buffer,
 			    u32 operation, efi_uintn_t sx,
 			    efi_uintn_t sy, efi_uintn_t dx,
@@ -88,14 +106,18 @@ efi_status_t EFIAPI gop_blt(struct efi_gop *this, struct efi_gop_pixel *buffer,
 	u32 *fb32 = gopobj->fb;
 	u16 *fb16 = gopobj->fb;
 
-	if (delta)
-		linelen = delta;
-	else
-		linelen = width;
-
 	EFI_ENTRY("%p, %p, %u, %zu, %zu, %zu, %zu, %zu, %zu, %zu", this,
 		  buffer, operation, sx, sy, dx, dy, width, height, delta);
 
+	if (delta) {
+		/* Check for 4 byte alignment */
+		if (delta & 3)
+			return EFI_EXIT(EFI_INVALID_PARAMETER);
+		linelen = delta >> 2;
+	} else {
+		linelen = width;
+	}
+
 	/* Check source rectangle */
 	switch (operation) {
 	case EFI_BLT_VIDEO_FILL:
diff --git a/lib/efi_selftest/efi_selftest_bitblt.c b/lib/efi_selftest/efi_selftest_bitblt.c
index 53cc633acc..404aaf0f6a 100644
--- a/lib/efi_selftest/efi_selftest_bitblt.c
+++ b/lib/efi_selftest/efi_selftest_bitblt.c
@@ -276,7 +276,7 @@ static int execute(void)
 	/* Copy port holes back to buffer */
 	ret = gop->blt(gop, bitmap, EFI_BLT_VIDEO_TO_BLT_BUFFER,
 		       94, 57 + DEPTH, 94, 57,
-		       90, 26, WIDTH);
+		       90, 26, WIDTH * sizeof(struct efi_gop_pixel));
 	if (ret != EFI_SUCCESS) {
 		efi_st_error("EFI_BLT_VIDEO_TO_BLT_BUFFER failed\n");
 		return EFI_ST_FAILURE;
-- 
2.16.1

