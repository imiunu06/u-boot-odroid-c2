From 89597e807bc36fade3aa1f07548f56745513e9e3 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 17 Dec 2017 19:30:21 +0100
Subject: [PATCH 1/1] efi_driver: EFI block driver

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 common/board_r.c                  |   3 +
 include/dm/uclass-id.h            |   1 +
 include/efi_driver.h              |  29 ++++
 include/efi_loader.h              |   2 +
 lib/Makefile                      |   1 +
 lib/efi_driver/Makefile           |  10 ++
 lib/efi_driver/efi_block_device.c |  57 +++++++
 lib/efi_driver/efi_uclass.c       | 319 ++++++++++++++++++++++++++++++++++++++
 8 files changed, 422 insertions(+)
 create mode 100644 include/efi_driver.h
 create mode 100644 lib/efi_driver/Makefile
 create mode 100644 lib/efi_driver/efi_block_device.c
 create mode 100644 lib/efi_driver/efi_uclass.c

diff --git a/common/board_r.c b/common/board_r.c
index 09167c13cc..5e7eb2d5cb 100644
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -717,7 +717,10 @@ static init_fnc_t init_sequence_r[] = {
 	set_cpu_clk_info, /* Setup clock information */
 #endif
 #ifdef CONFIG_EFI_LOADER
+	/* Setup EFI memory before any other EFI related code */
 	efi_memory_init,
+	/* Install EFI drivers */
+	efi_driver_init,
 #endif
 	stdio_init_tables,
 	initr_serial,
diff --git a/include/dm/uclass-id.h b/include/dm/uclass-id.h
index 3fc20834ae..07fabc3ce6 100644
--- a/include/dm/uclass-id.h
+++ b/include/dm/uclass-id.h
@@ -34,6 +34,7 @@ enum uclass_id {
 	UCLASS_CROS_EC,		/* Chrome OS EC */
 	UCLASS_DISPLAY,		/* Display (e.g. DisplayPort, HDMI) */
 	UCLASS_DMA,		/* Direct Memory Access */
+	UCLASS_EFI,		/* EFI managed devices */
 	UCLASS_ETH,		/* Ethernet device */
 	UCLASS_GPIO,		/* Bank of general-purpose I/O pins */
 	UCLASS_FIRMWARE,	/* Firmware */
diff --git a/include/efi_driver.h b/include/efi_driver.h
new file mode 100644
index 0000000000..5061b5f2f4
--- /dev/null
+++ b/include/efi_driver.h
@@ -0,0 +1,29 @@
+/*
+ *  EFI application loader
+ *
+ *  Copyright (c) 2017 Heinrich Schuchardt
+ *
+ *  SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef _EFI_DRIVER_H
+#define _EFI_DRIVER_H 1
+
+#include <common.h>
+#include <dm.h>
+#include <efi_loader.h>
+
+struct efi_driver_ops {
+	const efi_guid_t *protocol;
+	const efi_guid_t *child_protocol;
+};
+
+/*
+ * This structure adds internal fields to the driver binding protocol.
+ */
+struct efi_driver_binding_extended_protocol {
+	struct efi_driver_binding_protocol bp;
+	const struct efi_driver_ops *ops;
+};
+
+#endif /* _EFI_DRIVER_H */
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 672ad16464..54de58ad37 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -269,6 +269,8 @@ efi_status_t efi_get_memory_map(efi_uintn_t *memory_map_size,
 /* Adds a range into the EFI memory map */
 uint64_t efi_add_memory_map(uint64_t start, uint64_t pages, int memory_type,
 			    bool overlap_only_ram);
+/* Called by board init to initialize the EFI drivers */
+int efi_driver_init(void);
 /* Called by board init to initialize the EFI memory map */
 int efi_memory_init(void);
 /* Adds new or overrides configuration table entry to the system table */
diff --git a/lib/Makefile b/lib/Makefile
index 8cd779f8ca..0db41c19f3 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -8,6 +8,7 @@
 ifndef CONFIG_SPL_BUILD
 
 obj-$(CONFIG_EFI) += efi/
+obj-$(CONFIG_EFI_LOADER) += efi_driver/
 obj-$(CONFIG_EFI_LOADER) += efi_loader/
 obj-$(CONFIG_EFI_LOADER) += efi_selftest/
 obj-$(CONFIG_LZMA) += lzma/
diff --git a/lib/efi_driver/Makefile b/lib/efi_driver/Makefile
new file mode 100644
index 0000000000..8583f6fbcd
--- /dev/null
+++ b/lib/efi_driver/Makefile
@@ -0,0 +1,10 @@
+#
+# (C) Copyright 2017 Heinrich Schuchardt
+#
+#  SPDX-License-Identifier:     GPL-2.0+
+#
+
+# This file only gets included with CONFIG_EFI_LOADER set, so all
+# object inclusion implicitly depends on it
+
+obj-y += efi_uclass.o efi_block_device.o
diff --git a/lib/efi_driver/efi_block_device.c b/lib/efi_driver/efi_block_device.c
new file mode 100644
index 0000000000..c4adc55d94
--- /dev/null
+++ b/lib/efi_driver/efi_block_device.c
@@ -0,0 +1,57 @@
+/*
+ *  EFI drivers
+ *
+ *  Copyright (c) 2017 Heinrich Schuchardt
+ *
+ *  SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <efi_driver.h>
+
+static int efi_blk_probe(struct udevice *udev)
+{
+	struct blk_desc *desc = dev_get_uclass_platdata(udev);
+
+	part_init(desc);
+
+	return 0;
+}
+
+ulong efi_read(struct udevice *dev, lbaint_t blknr, lbaint_t blkcnt,
+	       void *buffer)
+{
+	ulong n = 0;
+
+	return n;
+}
+
+ulong efi_write(struct udevice *dev, lbaint_t blknr, lbaint_t blkcnt,
+		const void *buffer)
+{
+	ulong n = 0;
+
+	return n;
+}
+
+static const struct blk_ops efi_blk_ops = {
+	.read	= efi_read,
+	.write	= efi_write,
+};
+
+U_BOOT_DRIVER(efi_blk) = {
+	.name		= "efi_blk",
+	.id		= UCLASS_BLK,
+	.ops		= &efi_blk_ops,
+	.probe		= efi_blk_probe,
+};
+
+static const struct efi_driver_ops driver_ops = {
+	.protocol	= &efi_block_io_guid,
+	.child_protocol = &efi_block_io_guid,
+};
+
+U_BOOT_DRIVER(efi_block) = {
+	.name		= "EFI block driver",
+	.id		= UCLASS_EFI,
+	.ops		= &driver_ops,
+};
diff --git a/lib/efi_driver/efi_uclass.c b/lib/efi_driver/efi_uclass.c
new file mode 100644
index 0000000000..9d0163b233
--- /dev/null
+++ b/lib/efi_driver/efi_uclass.c
@@ -0,0 +1,319 @@
+/*
+ *  EFI drivers
+ *
+ *  Copyright (c) 2017 Heinrich Schuchardt
+ *
+ *  SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#define DEBUG 1
+
+#include <efi_driver.h>
+
+/*
+ * Check node type. We do not support partions as controller handles.
+ *
+ * @handle	handle to be checked
+ * @return	status code
+ */
+static efi_status_t check_node_type(efi_handle_t handle)
+{
+	efi_status_t r, ret = EFI_SUCCESS;
+	const struct efi_device_path *dp;
+
+	/* Open the device path protocol */
+	r = EFI_CALL(systab.boottime->open_protocol(
+			handle, &efi_guid_device_path, (void **)&dp,
+			NULL, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL));
+	if (r == EFI_SUCCESS && dp) {
+		/* Get the last node */
+		const struct efi_device_path *node = efi_dp_last_node(dp);
+		/* We do not support partitions as controller */
+		if (!node || node->type == DEVICE_PATH_TYPE_MEDIA_DEVICE)
+			ret = EFI_UNSUPPORTED;
+	}
+	return ret;
+}
+
+/*
+ * Check if the driver supports the controller.
+ *
+ * @this			driver binding protocol
+ * @controller_handle		handle of the controller
+ * @remaining_device_path	path specifying the child controller
+ * @return			status code
+ */
+static efi_status_t EFIAPI efi_uc_supported(
+		struct efi_driver_binding_protocol *this,
+		efi_handle_t controller_handle,
+		struct efi_device_path *remaining_device_path)
+{
+	efi_status_t r, ret;
+	void *interface;
+	struct efi_driver_binding_extended_protocol *bp =
+			(struct efi_driver_binding_extended_protocol *)this;
+
+	EFI_ENTRY("%p, %p, %ls", this, controller_handle,
+		  efi_dp_str(remaining_device_path));
+
+	ret = EFI_CALL(systab.boottime->open_protocol(
+			controller_handle, bp->ops->protocol,
+			&interface, this->driver_binding_handle,
+			controller_handle, EFI_OPEN_PROTOCOL_BY_DRIVER));
+	switch (ret) {
+	case EFI_ACCESS_DENIED:
+	case EFI_ALREADY_STARTED:
+		goto out;
+	case EFI_SUCCESS:
+		break;
+	default:
+		ret = EFI_UNSUPPORTED;
+		goto out;
+	}
+
+	ret = check_node_type(controller_handle);
+
+	r = EFI_CALL(systab.boottime->close_protocol(
+				controller_handle, bp->ops->protocol,
+				this->driver_binding_handle,
+				controller_handle));
+	if (r != EFI_SUCCESS)
+		ret = EFI_UNSUPPORTED;
+out:
+	return EFI_EXIT(ret);
+}
+
+/*
+ * Create child controllers and attach driver.
+ *
+ * @this			driver binding protocol
+ * @controller_handle		handle of the controller
+ * @remaining_device_path	path specifying the child controller
+ * @return			status code
+ */
+static efi_status_t EFIAPI efi_uc_start(
+		struct efi_driver_binding_protocol *this,
+		efi_handle_t controller_handle,
+		struct efi_device_path *remaining_device_path)
+{
+	efi_status_t r, ret;
+	void *interface;
+	struct efi_driver_binding_extended_protocol *bp =
+			(struct efi_driver_binding_extended_protocol *)this;
+
+	EFI_ENTRY("%p, %pUl, %ls", this, controller_handle,
+		  efi_dp_str(remaining_device_path));
+
+	/* Attach driver to controller */
+	ret = EFI_CALL(systab.boottime->open_protocol(
+			controller_handle, bp->ops->protocol,
+			&interface, this->driver_binding_handle,
+			controller_handle, EFI_OPEN_PROTOCOL_BY_DRIVER));
+	switch (ret) {
+	case EFI_ACCESS_DENIED:
+	case EFI_ALREADY_STARTED:
+		goto out;
+	case EFI_SUCCESS:
+		break;
+	default:
+		ret =  EFI_UNSUPPORTED;
+		goto out;
+	}
+	ret = check_node_type(controller_handle);
+	if (ret != EFI_SUCCESS) {
+		r = EFI_CALL(systab.boottime->close_protocol(
+				controller_handle, bp->ops->protocol,
+				this->driver_binding_handle,
+				controller_handle));
+		if (r != EFI_SUCCESS)
+			EFI_PRINT("Failure to close handle\n");
+		goto out;
+	}
+
+	/* TODO: driver specific stuff */
+
+out:
+	return EFI_EXIT(ret);
+}
+
+/*
+ * Remove a single child controller from the parent controller.
+ *
+ * @controller_handle	parent controller
+ * @child_handle	child controller
+ * @return		status code
+ */
+static efi_status_t disconnect_child(efi_handle_t controller_handle,
+				     efi_handle_t child_handle)
+{
+	efi_status_t ret;
+	efi_guid_t *guid_controller = NULL;
+	efi_guid_t *guid_child_controller = NULL;
+
+	ret = EFI_CALL(systab.boottime->close_protocol(
+				controller_handle, guid_controller,
+				child_handle, child_handle));
+	if (ret != EFI_SUCCESS) {
+		EFI_PRINT("Cannot close protocol\n");
+		return ret;
+	}
+	ret = EFI_CALL(systab.boottime->uninstall_protocol_interface(
+				child_handle, guid_child_controller, NULL));
+	if (ret != EFI_SUCCESS) {
+		EFI_PRINT("Cannot uninstall protocol interface\n");
+		return ret;
+	}
+	return ret;
+}
+
+/*
+ * Remove child controllers and disconnect the controller.
+ *
+ * @this			driver binding protocol
+ * @controller_handle		handle of the controller
+ * @number_of_children		number of child controllers to remove
+ * @child_handle_buffer		handles of the child controllers to remove
+ * @return			status code
+ */
+static efi_status_t EFIAPI efi_uc_stop(
+		struct efi_driver_binding_protocol *this,
+		efi_handle_t controller_handle,
+		size_t number_of_children,
+		efi_handle_t *child_handle_buffer)
+{
+	efi_status_t ret;
+	efi_uintn_t count;
+	struct efi_open_protocol_info_entry *entry_buffer;
+	efi_guid_t *guid_controller = NULL;
+
+	EFI_ENTRY("%p, %pUl, %zu, %p", this, controller_handle,
+		  number_of_children, child_handle_buffer);
+
+	/* Destroy provided child controllers */
+	if (number_of_children) {
+		efi_uintn_t i;
+
+		for (i = 0; i < number_of_children; ++i) {
+			ret = disconnect_child(controller_handle,
+					       child_handle_buffer[i]);
+			if (ret != EFI_SUCCESS)
+				return ret;
+		}
+		return EFI_SUCCESS;
+	}
+
+	/* Destroy all children */
+	ret = EFI_CALL(systab.boottime->open_protocol_information(
+					controller_handle, guid_controller,
+					&entry_buffer, &count));
+	if (ret != EFI_SUCCESS)
+		goto out;
+	while (count) {
+		if (entry_buffer[--count].attributes &
+		    EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER) {
+			ret = disconnect_child(
+					controller_handle,
+					entry_buffer[count].agent_handle);
+			if (ret != EFI_SUCCESS)
+				goto out;
+		}
+	}
+	ret = EFI_CALL(systab.boottime->free_pool(entry_buffer));
+	if (ret != EFI_SUCCESS)
+		printf("%s(%u) %s: ERROR: Cannot free pool\n",
+		       __FILE__, __LINE__, __func__);
+
+	/* Detach driver from controller */
+	ret = EFI_CALL(systab.boottime->close_protocol(
+			controller_handle, guid_controller,
+			this->driver_binding_handle, controller_handle));
+out:
+	return EFI_EXIT(ret);
+}
+
+static efi_status_t efi_add_driver(struct driver *drv)
+{
+	efi_status_t ret;
+	const struct efi_driver_ops *ops = drv->ops;
+	struct efi_driver_binding_extended_protocol *bp;
+
+	debug("EFI: Adding driver '%s'\n", drv->name);
+	if (!ops->protocol) {
+		printf("EFI: ERROR: protocol GUID missing for driver '%s'\n",
+		       drv->name);
+		return EFI_INVALID_PARAMETER;
+	}
+	bp = calloc(1, sizeof(struct efi_driver_binding_extended_protocol));
+	if (!bp)
+		return EFI_OUT_OF_RESOURCES;
+
+	bp->bp.supported = efi_uc_supported;
+	bp->bp.start = efi_uc_start;
+	bp->bp.stop = efi_uc_stop;
+	bp->bp.version = 0xffffffff;
+	bp->ops = drv->ops;
+
+	ret = efi_create_handle(&bp->bp.driver_binding_handle);
+	if (ret != EFI_SUCCESS) {
+		free(bp);
+		goto out;
+	}
+	bp->bp.image_handle = bp->bp.driver_binding_handle;
+	ret = efi_add_protocol(bp->bp.driver_binding_handle,
+			       &efi_guid_driver_binding_protocol, bp);
+	if (ret != EFI_SUCCESS) {
+		efi_delete_handle(bp->bp.driver_binding_handle);
+		free(bp);
+		goto out;
+	}
+out:
+	return ret;
+}
+
+/*
+ * Initialize the EFI drivers.
+ * Called by board_init_r().
+ *
+ * @return	0 = success, any other value will stop further execution
+ */
+int efi_driver_init(void)
+{
+	struct driver *drv;
+	int ret = 0;
+
+	/* Save 'gd' pointer */
+	efi_save_gd();
+
+	debug("EFI: Initializing EFI driver framework\n");
+	for (drv = ll_entry_start(struct driver, driver);
+	     drv < ll_entry_end(struct driver, driver); ++drv) {
+		if (drv->id == UCLASS_EFI) {
+			ret = efi_add_driver(drv);
+			if (ret) {
+				printf("EFI: ERROR: failed to add driver %s\n",
+				       drv->name);
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+static int efi_uc_init(struct uclass *class)
+{
+	printf("EFI: Initializing UCLASS_EFI\n");
+	return 0;
+}
+
+static int efi_uc_destroy(struct uclass *class)
+{
+	printf("Destroying  UCLASS_EFI\n");
+	return 0;
+}
+
+UCLASS_DRIVER(efi) = {
+	.name		= "efi",
+	.id		= UCLASS_EFI,
+	.init		= efi_uc_init,
+	.destroy	= efi_uc_destroy,
+};
-- 
2.15.1

