From a33211c1240f78da802bcbd047a9684eea6a8794 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 30 Jul 2017 15:52:37 +0200
Subject: [PATCH 1/1] efi_loader: write protocol GUID in OpenProtocol

To understand what is happening in protocol related boot services
it is necessary to know the protocol interface GUID.
Let's write a debug message.

Cc: Rob Clark <robdclark@gmail.com>
Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h          |  8 ++++++++
 lib/efi_loader/efi_boottime.c | 13 +++++++++++++
 2 files changed, 21 insertions(+)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index a89977fe0f..16f61c9e17 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -17,6 +17,7 @@
 
 int __efi_entry_check(void);
 int __efi_exit_check(void);
+const char *__efi_nesting(void);
 const char *__efi_nesting_inc(void);
 const char *__efi_nesting_dec(void);
 
@@ -64,6 +65,13 @@ const char *__efi_nesting_dec(void);
 	debug("%sEFI: Return From: %s\n", __efi_nesting_dec(), #exp); \
 	} while(0)
 
+/*
+ * Write GUID
+ */
+#define EFI_PRINT_GUID(txt, guid) ({ \
+	debug("%sEFI: %s %pUl\n", __efi_nesting(), txt, guid); \
+	})
+
 extern struct efi_runtime_services efi_runtime_services;
 extern struct efi_system_table systab;
 
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 194a40d424..f4867ab5be 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -109,6 +109,11 @@ static const char *indent_string(int level)
 	return &indent[max - level];
 }
 
+const char *__efi_nesting(void)
+{
+	return indent_string(nesting_level);
+}
+
 const char *__efi_nesting_inc(void)
 {
 	return indent_string(nesting_level++);
@@ -494,6 +499,7 @@ static efi_status_t EFIAPI efi_install_protocol_interface(void **handle,
 		r = EFI_INVALID_PARAMETER;
 		goto out;
 	}
+	EFI_PRINT_GUID("protocol", protocol);
 
 	/* Create new handle if requested. */
 	if (!*handle) {
@@ -553,6 +559,7 @@ static efi_status_t EFIAPI efi_uninstall_protocol_interface(void *handle,
 		r = EFI_INVALID_PARAMETER;
 		goto out;
 	}
+	EFI_PRINT_GUID("protocol", protocol);
 
 	/* Find the protocol on the handle */
 	r = efi_search_protocol(handle, protocol, &handler);
@@ -623,6 +630,7 @@ static efi_status_t efi_locate_handle(
 	case by_protocol:
 		if (!protocol)
 			return EFI_INVALID_PARAMETER;
+		EFI_PRINT_GUID("protocol", protocol);
 		break;
 	default:
 		return EFI_INVALID_PARAMETER;
@@ -1001,6 +1009,7 @@ static efi_status_t EFIAPI efi_open_protocol_information(efi_handle_t handle,
 		r = EFI_INVALID_PARAMETER;
 		goto out;
 	}
+	EFI_PRINT_GUID("protocol", protocol);
 
 	/* Find the protocol */
 	r = efi_search_protocol(handle, protocol, &handler);
@@ -1143,6 +1152,8 @@ static efi_status_t EFIAPI efi_locate_protocol(efi_guid_t *protocol,
 	if (!protocol || !protocol_interface)
 		return EFI_EXIT(EFI_INVALID_PARAMETER);
 
+	EFI_PRINT_GUID("protocol", protocol);
+
 	list_for_each(lhandle, &efi_obj_list) {
 		struct efi_object *efiobj;
 
@@ -1347,6 +1358,8 @@ static efi_status_t EFIAPI efi_open_protocol(
 		goto out;
 	}
 
+	EFI_PRINT_GUID("protocol", protocol);
+
 	switch (attributes) {
 	case EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL:
 	case EFI_OPEN_PROTOCOL_GET_PROTOCOL:
-- 
2.14.1

