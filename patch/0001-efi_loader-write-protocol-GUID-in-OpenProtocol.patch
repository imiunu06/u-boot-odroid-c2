From 516500efb460feb68196a1f524f1be083d3781ab Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 30 Jul 2017 15:52:37 +0200
Subject: [PATCH 1/1] efi_loader: write protocol GUID in OpenProtocol

To understand what is happening in protocol related boot services
it is necessary to know the protocol interface GUID.
Let's write a debug message.

Cc: Rob Clark <robdclark@gmail.com>
Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h          |  8 ++++++++
 lib/efi_loader/efi_boottime.c | 14 ++++++++++++++
 2 files changed, 22 insertions(+)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index 8358adea2f..e89407329a 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -17,6 +17,7 @@
 
 int __efi_entry_check(void);
 int __efi_exit_check(void);
+const char *__efi_nesting(void);
 const char *__efi_nesting_inc(void);
 const char *__efi_nesting_dec(void);
 
@@ -64,6 +65,13 @@ const char *__efi_nesting_dec(void);
 	debug("%sEFI: Return From: %s\n", __efi_nesting_dec(), #exp); \
 	} while(0)
 
+/*
+ * Write GUID
+ */
+#define EFI_PRINT_GUID(txt, guid) ({ \
+	debug("%sEFI: %s %pUl\n", __efi_nesting(), txt, guid); \
+	})
+
 extern struct efi_runtime_services efi_runtime_services;
 extern struct efi_system_table systab;
 
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index aec8debceb..1e2f9b4ced 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -109,6 +109,11 @@ static const char *indent_string(int level)
 	return &indent[max - level];
 }
 
+const char *__efi_nesting(void)
+{
+	return indent_string(nesting_level);
+}
+
 const char *__efi_nesting_inc(void)
 {
 	return indent_string(nesting_level++);
@@ -495,6 +500,7 @@ static efi_status_t EFIAPI efi_install_protocol_interface(void **handle,
 		r = EFI_INVALID_PARAMETER;
 		goto out;
 	}
+	EFI_PRINT_GUID("protocol", protocol);
 
 	/* Create new handle if requested. */
 	if (!*handle) {
@@ -554,6 +560,7 @@ static efi_status_t EFIAPI efi_uninstall_protocol_interface(void *handle,
 		r = EFI_INVALID_PARAMETER;
 		goto out;
 	}
+	EFI_PRINT_GUID("protocol", protocol);
 
 	/* Find the protocol on the handle */
 	r = efi_search_protocol(handle, protocol, &handler);
@@ -624,6 +631,7 @@ static efi_status_t efi_locate_handle(
 	case by_protocol:
 		if (!protocol)
 			return EFI_INVALID_PARAMETER;
+		EFI_PRINT_GUID("protocol", protocol);
 		break;
 	default:
 		return EFI_INVALID_PARAMETER;
@@ -959,6 +967,7 @@ efi_status_t EFIAPI efi_close_protocol(void *handle, const efi_guid_t *protocol,
 		r = EFI_INVALID_PARAMETER;
 		goto out;
 	}
+	EFI_PRINT_GUID("protocol", protocol);
 
 	list_for_each_entry(efiobj, &efi_obj_list, link) {
 		if (efiobj->handle != handle)
@@ -1001,6 +1010,7 @@ static efi_status_t EFIAPI efi_open_protocol_information(efi_handle_t handle,
 		r = EFI_INVALID_PARAMETER;
 		goto out;
 	}
+	EFI_PRINT_GUID("protocol", protocol);
 
 	/* Find the protocol */
 	r = efi_search_protocol(handle, protocol, &handler);
@@ -1143,6 +1153,8 @@ static efi_status_t EFIAPI efi_locate_protocol(const efi_guid_t *protocol,
 	if (!protocol || !protocol_interface)
 		return EFI_EXIT(EFI_INVALID_PARAMETER);
 
+	EFI_PRINT_GUID("protocol", protocol);
+
 	list_for_each(lhandle, &efi_obj_list) {
 		struct efi_object *efiobj;
 
@@ -1347,6 +1359,8 @@ efi_status_t EFIAPI efi_open_protocol(
 		goto out;
 	}
 
+	EFI_PRINT_GUID("protocol", protocol);
+
 	switch (attributes) {
 	case EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL:
 	case EFI_OPEN_PROTOCOL_GET_PROTOCOL:
-- 
2.14.1

