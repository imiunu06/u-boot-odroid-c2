From c05a9c02294f35a292c69093e488954871e47e73 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Mon, 29 Jan 2018 18:55:00 +0100
Subject: [PATCH 1/1] efi_loader: clean up efi_exit

Currently we require the handle of a loaded image to be the address of the
loaded image protocol.

In case an application passes the wrong handle this will lead to a long
jump with an invaild address in efi_exit().

With the patch we completely separate the handle and the loaded image
protocol.

Before making a long jump we check a magic cookie in one of the private
fields of the loaded image protocol.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c                 | 13 ++++----
 include/efi_api.h             |  5 +--
 include/efi_loader.h          |  2 +-
 lib/efi_loader/efi_boottime.c | 75 ++++++++++++++++++++++++++-----------------
 4 files changed, 57 insertions(+), 38 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 4233d36b72..636bc774c3 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -159,7 +159,7 @@ static efi_status_t do_bootefi_exec(void *efi, void *fdt,
 				    struct efi_device_path *image_path)
 {
 	struct efi_loaded_image loaded_image_info = {};
-	struct efi_object loaded_image_info_obj = {};
+	efi_handle_t handle;
 	struct efi_device_path *memdp = NULL;
 	ulong ret;
 
@@ -187,7 +187,11 @@ static efi_status_t do_bootefi_exec(void *efi, void *fdt,
 	if (!efi_obj_list_initalized)
 		efi_init_obj_list();
 
-	efi_setup_loaded_image(&loaded_image_info, &loaded_image_info_obj,
+	ret = efi_create_handle(&handle);
+	if (ret != EFI_SUCCESS)
+		return EFI_OUT_OF_RESOURCES;
+
+	efi_setup_loaded_image(&loaded_image_info, handle,
 			       device_path, image_path);
 
 	/*
@@ -268,12 +272,9 @@ static efi_status_t do_bootefi_exec(void *efi, void *fdt,
 	}
 #endif
 
-	ret = efi_do_enter(loaded_image_info_obj.handle, &systab, entry);
+	ret = efi_do_enter(handle, &systab, entry);
 
 exit:
-	/* image has returned, loaded-image obj goes *poof*: */
-	list_del(&loaded_image_info_obj.link);
-
 	return ret;
 }
 
diff --git a/include/efi_api.h b/include/efi_api.h
index 205f8f1f70..26572f1cd2 100644
--- a/include/efi_api.h
+++ b/include/efi_api.h
@@ -280,8 +280,9 @@ struct efi_loaded_image {
 
 	/* Below are efi loader private fields */
 #ifdef CONFIG_EFI_LOADER
-	efi_status_t exit_status;
-	struct jmp_buf_data exit_jmp;
+	efi_status_t exit_status;	/* exit status calling efi_exit() */
+	u64 magic;			/* magic cookie for jump buffer */
+	struct jmp_buf_data exit_jmp;	/* jump buffer used by efi_exit() */
 #endif
 };
 
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 21c03c5c28..d51ecdc818 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -279,7 +279,7 @@ int efi_memory_init(void);
 efi_status_t efi_install_configuration_table(const efi_guid_t *guid, void *table);
 /* Sets up a loaded image */
 efi_status_t efi_setup_loaded_image(
-			struct efi_loaded_image *info, struct efi_object *obj,
+			struct efi_loaded_image *info, efi_handle_t handle,
 			struct efi_device_path *device_path,
 			struct efi_device_path *file_path);
 efi_status_t efi_load_image_from_path(struct efi_device_path *file_path,
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index da93498b36..717231ce1a 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -18,6 +18,9 @@
 #include <inttypes.h>
 #include <watchdog.h>
 
+/* U-Boot long jump cookie 'UBootJmp' */
+#define EFI_LONGJMP_MAGIC_COOKIE 0x706D4A746F6F4255
+
 DECLARE_GLOBAL_DATA_PTR;
 
 /* Task priority level */
@@ -1355,17 +1358,12 @@ static efi_status_t EFIAPI efi_install_configuration_table_ext(efi_guid_t *guid,
  * @return		status code
  */
 efi_status_t efi_setup_loaded_image(
-			struct efi_loaded_image *info, struct efi_object *obj,
+			struct efi_loaded_image *info, efi_handle_t handle,
 			struct efi_device_path *device_path,
 			struct efi_device_path *file_path)
 {
 	efi_status_t ret;
 
-	/* Add internal object to object list */
-	efi_add_handle(obj);
-	/* efi_exit() assumes that the handle points to the info */
-	obj->handle = info;
-
 	info->file_path = file_path;
 
 	if (device_path) {
@@ -1374,7 +1372,7 @@ efi_status_t efi_setup_loaded_image(
 		 * When asking for the device path interface, return
 		 * bootefi_device_path
 		 */
-		ret = efi_add_protocol(obj->handle, &efi_guid_device_path,
+		ret = efi_add_protocol(handle, &efi_guid_device_path,
 				       device_path);
 		if (ret != EFI_SUCCESS)
 			goto failure;
@@ -1384,17 +1382,16 @@ efi_status_t efi_setup_loaded_image(
 	 * When asking for the loaded_image interface, just
 	 * return handle which points to loaded_image_info
 	 */
-	ret = efi_add_protocol(obj->handle, &efi_guid_loaded_image, info);
+	ret = efi_add_protocol(handle, &efi_guid_loaded_image, info);
 	if (ret != EFI_SUCCESS)
 		goto failure;
 
-	ret = efi_add_protocol(obj->handle, &efi_guid_console_control,
+	ret = efi_add_protocol(handle, &efi_guid_console_control,
 			       (void *)&efi_console_control);
 	if (ret != EFI_SUCCESS)
 		goto failure;
 
-	ret = efi_add_protocol(obj->handle,
-			       &efi_guid_device_path_to_text_protocol,
+	ret = efi_add_protocol(handle, &efi_guid_device_path_to_text_protocol,
 			       (void *)&efi_device_path_to_text);
 	if (ret != EFI_SUCCESS)
 		goto failure;
@@ -1477,14 +1474,21 @@ static efi_status_t EFIAPI efi_load_image(bool boot_policy,
 					  efi_handle_t *image_handle)
 {
 	struct efi_loaded_image *info;
-	struct efi_object *obj;
+	efi_handle_t handle;
 	efi_status_t ret;
 
 	EFI_ENTRY("%d, %p, %pD, %p, %ld, %p", boot_policy, parent_image,
 		  file_path, source_buffer, source_size, image_handle);
 
+	ret = efi_create_handle(&handle);
+	if (ret != EFI_SUCCESS)
+		return EFI_EXIT(ret);
+
 	info = calloc(1, sizeof(*info));
-	obj = calloc(1, sizeof(*obj));
+	if (!info) {
+		ret = EFI_OUT_OF_RESOURCES;
+		goto failure2;
+	}
 
 	if (!source_buffer) {
 		struct efi_device_path *dp, *fp;
@@ -1497,14 +1501,14 @@ static efi_status_t EFIAPI efi_load_image(bool boot_policy,
 		 * file parts:
 		 */
 		efi_dp_split_file_path(file_path, &dp, &fp);
-		ret = efi_setup_loaded_image(info, obj, dp, fp);
+		ret = efi_setup_loaded_image(info, handle, dp, fp);
 		if (ret != EFI_SUCCESS)
 			goto failure;
 	} else {
 		/* In this case, file_path is the "device" path, ie.
 		 * something like a HARDWARE_DEVICE:MEMORY_MAPPED
 		 */
-		ret = efi_setup_loaded_image(info, obj, file_path, NULL);
+		ret = efi_setup_loaded_image(info, handle, file_path, NULL);
 		if (ret != EFI_SUCCESS)
 			goto failure;
 	}
@@ -1515,11 +1519,12 @@ static efi_status_t EFIAPI efi_load_image(bool boot_policy,
 	}
 	info->system_table = &systab;
 	info->parent_handle = parent_image;
-	*image_handle = obj->handle;
+	*image_handle = handle;
 	return EFI_EXIT(EFI_SUCCESS);
 failure:
 	free(info);
-	efi_delete_handle(obj);
+failure2:
+	efi_delete_handle(handle);
 	return EFI_EXIT(ret);
 }
 
@@ -1578,6 +1583,9 @@ static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
 		return EFI_EXIT(info->exit_status);
 	}
 
+	/* Add our magic cookie. We check it in efi_exit(). */
+	info->magic = EFI_LONGJMP_MAGIC_COOKIE;
+
 	ret = EFI_CALL(entry(image_handle, &systab));
 
 	/*
@@ -1596,6 +1604,8 @@ static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
  * See the Unified Extensible Firmware Interface (UEFI) specification
  * for details.
  *
+ * TODO: We should call the unload procedure of the loaded image protocol.
+ *
  * @image_handle	handle of the application or driver that is exiting
  * @exit_status		status code
  * @exit_data_size	size of the buffer in bytes
@@ -1606,22 +1616,29 @@ static efi_status_t EFIAPI efi_exit(efi_handle_t image_handle,
 			efi_status_t exit_status, unsigned long exit_data_size,
 			int16_t *exit_data)
 {
-	/*
-	 * We require that the handle points to the original loaded
-	 * image protocol interface.
-	 *
-	 * For getting the longjmp address this is safer than locating
-	 * the protocol because the protocol may have been reinstalled
-	 * pointing to another memory location.
-	 *
-	 * TODO: We should call the unload procedure of the loaded
-	 *	 image protocol.
-	 */
-	struct efi_loaded_image *loaded_image_info = (void*)image_handle;
+	struct efi_loaded_image *loaded_image_info;
+	struct efi_handler *handler;
+	efi_status_t ret;
 
 	EFI_ENTRY("%p, %ld, %ld, %p", image_handle, exit_status,
 		  exit_data_size, exit_data);
 
+	/* Retrieve the loaded image protocol */
+	ret = efi_search_protocol(image_handle, &efi_guid_loaded_image,
+				  &handler);
+	if (ret != EFI_SUCCESS)
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+	loaded_image_info = handler->protocol_interface;
+
+	/* Verify that the longjmp address is valid */
+	if (loaded_image_info->magic != EFI_LONGJMP_MAGIC_COOKIE) {
+		EFI_PRINT("Invalid magic cookie\n");
+		return EFI_EXIT(EFI_INVALID_PARAMETER);
+	}
+
+	/* Invalidate the magic cookie. The code never exits twice. */
+	loaded_image_info->magic = 0;
+
 	/* Make sure entry/exit counts for EFI world cross-overs match */
 	EFI_EXIT(exit_status);
 
-- 
2.14.2

