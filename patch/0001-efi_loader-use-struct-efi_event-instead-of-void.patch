From 26e7a5a6157af122d49f3344505542a85e685d6e Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 15 Jul 2017 11:50:08 +0200
Subject: [PATCH 1/1] efi_loader: use struct efi_event * instead of void *

In our implementation the internal structure of events is known.
So use the known type instead of void.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_api.h             | 23 +++++++++++++----------
 lib/efi_loader/efi_boottime.c | 25 ++++++++++++++-----------
 2 files changed, 27 insertions(+), 21 deletions(-)

diff --git a/include/efi_api.h b/include/efi_api.h
index ea63e80b47..a1f8221111 100644
--- a/include/efi_api.h
+++ b/include/efi_api.h
@@ -31,6 +31,8 @@ enum efi_event_type {
 #define EVT_NOTIFY_WAIT		0x00000100
 #define EVT_NOTIFY_SIGNAL	0x00000200
 
+struct efi_event;
+
 /* EFI Boot Services table */
 struct efi_boot_services {
 	struct efi_table_hdr hdr;
@@ -48,16 +50,17 @@ struct efi_boot_services {
 
 	efi_status_t (EFIAPI *create_event)(enum efi_event_type type,
 			unsigned long notify_tpl,
-			void (EFIAPI *notify_function) (void *event,
-							void *context),
-			void *notify_context, void **event);
-	efi_status_t (EFIAPI *set_timer)(void *event, int type,
+			void (EFIAPI *notify_function) (
+					struct efi_event *event,
+					void *context),
+			void *notify_context, struct efi_event **event);
+	efi_status_t (EFIAPI *set_timer)(struct efi_event *event, int type,
 			uint64_t trigger_time);
 	efi_status_t (EFIAPI *wait_for_event)(unsigned long number_of_events,
-			void *event, unsigned long *index);
-	efi_status_t (EFIAPI *signal_event)(void *event);
-	efi_status_t (EFIAPI *close_event)(void *event);
-	efi_status_t (EFIAPI *check_event)(void *event);
+			struct efi_event **event, unsigned long *index);
+	efi_status_t (EFIAPI *signal_event)(struct efi_event *event);
+	efi_status_t (EFIAPI *close_event)(struct efi_event *event);
+	efi_status_t (EFIAPI *check_event)(struct efi_event *event);
 #define EFI_NATIVE_INTERFACE	0x00000000
 	efi_status_t (EFIAPI *install_protocol_interface)(
 			void **handle, efi_guid_t *protocol,
@@ -71,7 +74,7 @@ struct efi_boot_services {
 					       void **);
 	void *reserved;
 	efi_status_t (EFIAPI *register_protocol_notify)(
-			efi_guid_t *protocol, void *event,
+			efi_guid_t *protocol, struct efi_event *event,
 			void **registration);
 	efi_status_t (EFIAPI *locate_handle)(
 			enum efi_locate_search_type search_type,
@@ -374,7 +377,7 @@ struct efi_simple_input_interface {
 	efi_status_t(EFIAPI *read_key_stroke)(
 			struct efi_simple_input_interface *this,
 			struct efi_input_key *key);
-	void *wait_for_key;
+	struct efi_event *wait_for_key;
 };
 
 #define CONSOLE_CONTROL_GUID \
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index fa264f3f3d..0eda465359 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -166,13 +166,14 @@ static efi_status_t EFIAPI efi_free_pool_ext(void *buffer)
  * Our event capabilities are very limited. Only support a single
  * event to exist, so we don't need to maintain lists.
  */
-static struct {
+static struct efi_event {
 	enum efi_event_type type;
 	u32 trigger_type;
 	u32 trigger_time;
 	u64 trigger_next;
 	unsigned long notify_tpl;
-	void (EFIAPI *notify_function) (void *event, void *context);
+	void (EFIAPI *notify_function) (struct efi_event *event,
+					void *context);
 	void *notify_context;
 } efi_event = {
 	/* Disable timers on bootup */
@@ -181,9 +182,10 @@ static struct {
 
 static efi_status_t EFIAPI efi_create_event(
 			enum efi_event_type type, ulong notify_tpl,
-			void (EFIAPI *notify_function) (void *event,
-							void *context),
-			void *notify_context, void **event)
+			void (EFIAPI *notify_function) (
+					struct efi_event *event,
+					void *context),
+			void *notify_context, struct efi_event **event)
 {
 	EFI_ENTRY("%d, 0x%lx, %p, %p", type, notify_tpl, notify_function,
 		  notify_context);
@@ -231,7 +233,7 @@ void efi_timer_check(void)
 	WATCHDOG_RESET();
 }
 
-static efi_status_t EFIAPI efi_set_timer(void *event, int type,
+static efi_status_t EFIAPI efi_set_timer(struct efi_event *event, int type,
 					 uint64_t trigger_time)
 {
 	/* We don't have 64bit division available everywhere, so limit timer
@@ -268,7 +270,8 @@ static efi_status_t EFIAPI efi_set_timer(void *event, int type,
 }
 
 static efi_status_t EFIAPI efi_wait_for_event(unsigned long num_events,
-					      void *event, unsigned long *index)
+					      struct efi_event **event,
+					      unsigned long *index)
 {
 	u64 now;
 
@@ -281,20 +284,20 @@ static efi_status_t EFIAPI efi_wait_for_event(unsigned long num_events,
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
-static efi_status_t EFIAPI efi_signal_event(void *event)
+static efi_status_t EFIAPI efi_signal_event(struct efi_event *event)
 {
 	EFI_ENTRY("%p", event);
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
-static efi_status_t EFIAPI efi_close_event(void *event)
+static efi_status_t EFIAPI efi_close_event(struct efi_event *event)
 {
 	EFI_ENTRY("%p", event);
 	efi_event.trigger_next = -1ULL;
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
-static efi_status_t EFIAPI efi_check_event(void *event)
+static efi_status_t EFIAPI efi_check_event(struct efi_event *event)
 {
 	EFI_ENTRY("%p", event);
 	return EFI_EXIT(EFI_NOT_READY);
@@ -429,7 +432,7 @@ static efi_status_t EFIAPI efi_uninstall_protocol_interface_ext(void *handle,
 }
 
 static efi_status_t EFIAPI efi_register_protocol_notify(efi_guid_t *protocol,
-							void *event,
+							struct efi_event *event,
 							void **registration)
 {
 	EFI_ENTRY("%p, %p, %p", protocol, event, registration);
-- 
2.13.2

