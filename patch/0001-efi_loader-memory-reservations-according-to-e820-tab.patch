From 3cb6cc80546aa2b42f22062363cbfd65022d878b Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 14 Jan 2018 00:33:30 +0100
Subject: [PATCH 1/1] efi_loader: memory reservations according to e820 table

On the x86 architecture the e820 BIOS table defines reserved memory.
Mark it as EFI reserved memory.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_memory.c | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/lib/efi_loader/efi_memory.c b/lib/efi_loader/efi_memory.c
index aaf64421a3..c789e9986c 100644
--- a/lib/efi_loader/efi_memory.c
+++ b/lib/efi_loader/efi_memory.c
@@ -10,6 +10,9 @@
 #include <efi_loader.h>
 #include <malloc.h>
 #include <asm/global_data.h>
+#ifdef CONFIG_X86
+#include <asm/e820.h>
+#endif
 #include <libfdt_env.h>
 #include <linux/list_sort.h>
 #include <inttypes.h>
@@ -493,6 +496,29 @@ __weak void efi_add_known_memory(void)
 	}
 }
 
+/*
+ * Create reservations according to the BIOS e820 table.
+ */
+static void e820_memory_reservation(void) {
+#ifdef CONFIG_X86
+	struct e820entry e820[32];
+	unsigned int i, num;
+	unsigned long start, pages;
+	
+	num = install_e820_map(ARRAY_SIZE(e820), e820);
+	
+	for (i = 0; i < num; ++i) {
+		if (e820[i].type == E820_RESERVED) {
+			start = e820[i].addr;
+			pages = ALIGN(e820[i].size, EFI_PAGE_SIZE) >>
+				EFI_PAGE_SHIFT;
+			efi_add_memory_map(start, pages,
+			   EFI_RESERVED_MEMORY_TYPE, false);
+		}
+	}
+#endif
+}
+
 int efi_memory_init(void)
 {
 	unsigned long runtime_start, runtime_end, runtime_pages;
@@ -525,6 +551,7 @@ int efi_memory_init(void)
 
 	efi_bounce_buffer = (void*)(uintptr_t)efi_bounce_buffer_addr;
 #endif
+	e820_memory_reservation();
 
 	return 0;
 }
-- 
2.15.1

