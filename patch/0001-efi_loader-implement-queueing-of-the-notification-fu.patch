From 55e5f68e35cab0d30d71a002f2d1053a1d6d1ae4 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Wed, 13 Sep 2017 08:37:24 +0200
Subject: [PATCH 1/1] efi_loader: implement queueing of the notification
 function

For the correct implementation of the task priority level (TPL)
calling the notification function must be queued.

Add a status field 'queued' to events.

Rename function efi_signal_event to efi_notify_event.
If a notification function exists, we set status queued here
and reset it after we have called the function.
A later patch will add a check of the TPL here.

In efi_create_event and efi_close_event unset the queued status.

In function efi_wait_for_event and efi_check_event
queue the notification function.

In efi_timer_check call the efi_notify_event
if the status queued is set.
For all timer events set status signaled.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h          |  4 +++-
 lib/efi_loader/efi_boottime.c | 50 ++++++++++++++++++++++++++++++++-----------
 2 files changed, 40 insertions(+), 14 deletions(-)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index f27192555e..ac7d23008a 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -131,7 +131,8 @@ struct efi_object {
  * @nofify_function:	Function to call when the event is triggered
  * @notify_context:	Data to be passed to the notify function
  * @trigger_type:	Type of timer, see efi_set_timer
- * @signaled:		The notify function was already called
+ * @queued:		The notification functionis queued
+ * @signaled:		The event occured
  */
 struct efi_event {
 	uint32_t type;
@@ -141,6 +142,7 @@ struct efi_event {
 	u64 trigger_next;
 	u64 trigger_time;
 	enum efi_timer_delay trigger_type;
+	int queued;
 	int signaled;
 };
 
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 2c9379a8ae..c46334165a 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -157,15 +157,15 @@ static u64 efi_div10(u64 a)
 	return ret;
 }
 
-void efi_signal_event(struct efi_event *event)
+void efi_notify_event(struct efi_event *event)
 {
-	if (event->signaled)
-		return;
-	event->signaled = 1;
-	if (event->type & EVT_NOTIFY_SIGNAL) {
+	if (event->notify_function) {
+		event->queued = 1;
+		/* Put missing TPL check here */
 		EFI_CALL_VOID(event->notify_function(event,
 						     event->notify_context));
 	}
+	event->queued = 0;
 }
 
 static efi_status_t efi_unsupported(const char *funcname)
@@ -276,6 +276,7 @@ efi_status_t efi_create_event(uint32_t type, UINTN notify_tpl,
 		efi_events[i].notify_context = notify_context;
 		/* Disable timers on bootup */
 		efi_events[i].trigger_next = -1ULL;
+		efi_events[i].queued = 0;
 		efi_events[i].signaled = 0;
 		*event = &efi_events[i];
 		return EFI_SUCCESS;
@@ -307,17 +308,27 @@ void efi_timer_check(void)
 	u64 now = timer_get_us();
 
 	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
-		if (!efi_events[i].type ||
-		    !(efi_events[i].type & EVT_TIMER) ||
-		    efi_events[i].trigger_type == EFI_TIMER_STOP ||
+		if (!efi_events[i].type)
+			continue
+		if (efi_events[i].queued)
+			efi_notify_event(&efi_events[i]);
+		if (!(efi_events[i].type & EVT_TIMER) ||
 		    now < efi_events[i].trigger_next)
 			continue;
-		if (efi_events[i].trigger_type == EFI_TIMER_PERIODIC) {
+		switch(efi_events[i].trigger_type) {
+		case EFI_TIMER_RELATIVE:
+			if (efi_events[i].signaled)
+				continue;
+			break;
+		case EFI_TIMER_PERIODIC:
 			efi_events[i].trigger_next +=
 				efi_events[i].trigger_time;
-			efi_events[i].signaled = 0;
+			break;
+		default:
+			continue;
 		}
-		efi_signal_event(&efi_events[i]);
+		efi_events[i].signaled = 1;
+		efi_notify_event(&efi_events[i]);
 	}
 	WATCHDOG_RESET();
 }
@@ -377,6 +388,7 @@ static efi_status_t EFIAPI efi_wait_for_event(unsigned long num_events,
 	/* Check parameters */
 	if (!num_events || !event)
 		return EFI_EXIT(EFI_INVALID_PARAMETER);
+	/* Put missing TPL check here */
 	for (i = 0; i < num_events; ++i) {
 		for (j = 0; j < ARRAY_SIZE(efi_events); ++j) {
 			if (event[i] == &efi_events[j])
@@ -386,6 +398,9 @@ static efi_status_t EFIAPI efi_wait_for_event(unsigned long num_events,
 known_event:
 		if (!event[i]->type || event[i]->type & EVT_NOTIFY_SIGNAL)
 			return EFI_EXIT(EFI_INVALID_PARAMETER);
+		if (!event[i]->signaled) {
+			efi_notify_event(event[i]);
+		}
 	}
 
 	/* Wait for signal */
@@ -418,7 +433,12 @@ static efi_status_t EFIAPI efi_signal_event_ext(struct efi_event *event)
 	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
 		if (event != &efi_events[i])
 			continue;
-		efi_signal_event(event);
+		if (event->signaled)
+			break;
+		event->signaled = 1;
+		if (event->type & EVT_NOTIFY_SIGNAL) {
+			efi_signal_event(event);
+		}
 		break;
 	}
 	return EFI_EXIT(EFI_SUCCESS);
@@ -433,6 +453,7 @@ static efi_status_t EFIAPI efi_close_event(struct efi_event *event)
 		if (event == &efi_events[i]) {
 			event->type = 0;
 			event->trigger_next = -1ULL;
+			event->queued = 0;
 			event->signaled = 0;
 			return EFI_EXIT(EFI_SUCCESS);
 		}
@@ -451,8 +472,11 @@ static efi_status_t EFIAPI efi_check_event(struct efi_event *event)
 			continue;
 		if (!event->type || event->type & EVT_NOTIFY_SIGNAL)
 			break;
-		if (event->signaled)
+		if (!event->signaled) {
+			efi_notify_signal(event);
+		if (event->signaled) {
 			return EFI_EXIT(EFI_SUCCESS);
+		}
 		return EFI_EXIT(EFI_NOT_READY);
 	}
 	return EFI_EXIT(EFI_INVALID_PARAMETER);
-- 
2.11.0

