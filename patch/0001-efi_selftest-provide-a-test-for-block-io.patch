From 471c9bd4c110b7f002a6ea9f5ae2bae112c376af Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Mon, 18 Dec 2017 23:16:03 +0100
Subject: [PATCH 1/1] efi_selftest: provide a test for block io

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_selftest/Makefile                    |   1 +
 lib/efi_selftest/efi_selftest_block_device.c | 395 +++++++++++++++++++++++++++
 lib/efi_selftest/efi_selftest_disk_image.h   |  69 +++++
 3 files changed, 465 insertions(+)
 create mode 100644 lib/efi_selftest/efi_selftest_block_device.c
 create mode 100644 lib/efi_selftest/efi_selftest_disk_image.h

diff --git a/lib/efi_selftest/Makefile b/lib/efi_selftest/Makefile
index e549553c82..547e7e0098 100644
--- a/lib/efi_selftest/Makefile
+++ b/lib/efi_selftest/Makefile
@@ -9,6 +9,7 @@
 
 obj-$(CONFIG_CMD_BOOTEFI_SELFTEST) += \
 efi_selftest.o \
+efi_selftest_block_device.o \
 efi_selftest_controllers.o \
 efi_selftest_console.o \
 efi_selftest_devicepath.o \
diff --git a/lib/efi_selftest/efi_selftest_block_device.c b/lib/efi_selftest/efi_selftest_block_device.c
new file mode 100644
index 0000000000..0637a0d627
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest_block_device.c
@@ -0,0 +1,395 @@
+/*
+ * efi_selftest_block
+ *
+ * Copyright (c) 2017 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ *
+ * This test checks the driver for block IO devices.
+ * A disk image is created in memory.
+ * A handle is created for the new block IO device.
+ * The block I/O protocol is installed on the handle.
+ * ConnectController is used to setup partitions and to install the simple
+ * file protocol.
+ * A known file is read from the file system and verified.
+ */
+
+#include <efi_selftest.h>
+#include "efi_selftest_disk_image.h"
+
+/* Block size of compressed disk image */
+#define COMPRESSED_DISK_IMAGE_BLOCK_SIZE 8
+
+/* Binary logarithm of the block size */
+#define LB_BLOCK_SIZE 9
+
+static struct efi_boot_services *boottime;
+
+static const efi_guid_t block_io_protocol_guid = BLOCK_IO_GUID;
+static const efi_guid_t guid_device_path = DEVICE_PATH_GUID;
+static const efi_guid_t guid_simple_file_system_protocol =
+					EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
+static efi_guid_t guid_vendor =
+	EFI_GUID(0xdbca4c98, 0x6cb0, 0x694d,
+		 0x08, 0x72, 0x81, 0x9c, 0x65, 0x0c, 0xb7, 0xb8);
+
+static struct efi_device_path *dp;
+
+/* One 8 byte block of the compressed disk image */
+struct line {
+	size_t addr;
+	char *line;
+};
+
+/* Compressed disk image */
+struct compressed_disk_image {
+	size_t length;
+	struct line lines[];
+};
+
+static const struct compressed_disk_image img = EFI_ST_DISK_IMG;
+
+/* Decompressed disk image */
+static u8 *image;
+
+/*
+ * Reset service of the block IO protocol.
+ *
+ * @this	block IO protocol
+ * @return	status code
+ */
+static efi_status_t EFIAPI reset(
+			struct efi_block_io *this,
+			char extended_verification)
+{
+	return EFI_SUCCESS;
+}
+
+/*
+ * Read service of the block IO protocol.
+ *
+ * @this	block IO protocol
+ * @media_id	media id
+ * @lba		start of the read in logical blocks
+ * @buffer_size	number of bytes to read
+ * @buffer	target buffer
+ * @return	status code
+ */
+static efi_status_t EFIAPI read_blocks(
+			struct efi_block_io *this, u32 media_id, u64 lba,
+			efi_uintn_t buffer_size, void *buffer)
+{
+	u8 *start;
+
+	if ((lba << LB_BLOCK_SIZE) + buffer_size > img.length)
+		return EFI_INVALID_PARAMETER;
+	start = image + (lba << LB_BLOCK_SIZE);
+
+	boottime->copy_mem(buffer, start, buffer_size);
+
+	return EFI_SUCCESS;
+}
+
+/*
+ * Write service of the block IO protocol.
+ *
+ * @this	block IO protocol
+ * @media_id	media id
+ * @lba		start of the write in logical blocks
+ * @buffer_size	number of bytes to read
+ * @buffer	source buffer
+ * @return	status code
+ */
+static efi_status_t EFIAPI write_blocks(
+			struct efi_block_io *this, u32 media_id, u64 lba,
+			efi_uintn_t buffer_size, void *buffer)
+{
+	u8 *start;
+
+	if ((lba << LB_BLOCK_SIZE) + buffer_size > img.length)
+		return EFI_INVALID_PARAMETER;
+	start = image + (lba << LB_BLOCK_SIZE);
+
+	boottime->copy_mem(start, buffer, buffer_size);
+
+	return EFI_SUCCESS;
+}
+
+/*
+ * Flush service of the block IO protocol.
+ *
+ * @this	block IO protocol
+ * @return	status code
+ */
+static efi_status_t EFIAPI flush_blocks(struct efi_block_io *this)
+{
+	return EFI_SUCCESS;
+}
+
+/*
+ * Decompress the disk image.
+ *
+ * @image	decompressed disk image
+ * @return	status code
+ */
+static efi_status_t decompress(u8 **image)
+{
+	u8 *buf;
+	size_t i;
+	size_t addr;
+	size_t len;
+	efi_status_t ret;
+
+	ret = boottime->allocate_pool(EFI_LOADER_DATA, img.length,
+				      (void **)&buf);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Out of memory\n");
+		return ret;
+	}
+	boottime->set_mem(buf, img.length, 0);
+
+	for (i = 0; ; ++i) {
+		if (!img.lines[i].line)
+			break;
+		addr = img.lines[i].addr;
+		len = COMPRESSED_DISK_IMAGE_BLOCK_SIZE;
+		if (addr + len > img.length)
+			len = img.length - addr;
+		boottime->copy_mem(buf + addr, img.lines[i].line, len);
+	}
+	*image = buf;
+	return ret;
+}
+
+static struct efi_block_io_media media;
+
+static struct efi_block_io block_io = {
+	.media = &media,
+	.reset = reset,
+	.read_blocks = read_blocks,
+	.write_blocks = write_blocks,
+	.flush_blocks = flush_blocks,
+};
+
+/* Handle for the block IO device */
+static efi_handle_t disk_handle;
+
+/*
+ * Setup unit test.
+ *
+ * @handle:	handle of the loaded image
+ * @systable:	system table
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int setup(const efi_handle_t handle,
+		 const struct efi_system_table *systable)
+{
+	efi_status_t ret;
+	struct efi_device_path_vendor vendor_node;
+	struct efi_device_path end_node;
+
+	boottime = systable->boottime;
+
+	decompress(&image);
+
+	block_io.media->block_size = 1 << LB_BLOCK_SIZE;
+	block_io.media->last_block = img.length >> LB_BLOCK_SIZE;
+
+	ret = boottime->install_protocol_interface(
+				&disk_handle, &block_io_protocol_guid,
+				EFI_NATIVE_INTERFACE, &block_io);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to install block I/O protocol\n");
+		return EFI_ST_FAILURE;
+	}
+
+	ret = boottime->allocate_pool(EFI_LOADER_DATA,
+				      sizeof(struct efi_device_path_vendor) +
+				      sizeof(struct efi_device_path),
+				      (void **)&dp);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Out of memory\n");
+		return EFI_ST_FAILURE;
+	}
+	vendor_node.dp.type = DEVICE_PATH_TYPE_HARDWARE_DEVICE;
+	vendor_node.dp.sub_type = DEVICE_PATH_SUB_TYPE_VENDOR;
+	vendor_node.dp.length = sizeof(struct efi_device_path_vendor);
+
+	boottime->copy_mem(&vendor_node.guid, &guid_vendor,
+			   sizeof(efi_guid_t));
+	boottime->copy_mem(dp, &vendor_node,
+			   sizeof(struct efi_device_path_vendor));
+	end_node.type = DEVICE_PATH_TYPE_END;
+	end_node.sub_type = DEVICE_PATH_SUB_TYPE_END;
+	end_node.length = sizeof(struct efi_device_path);
+
+	boottime->copy_mem((char *)dp + sizeof(struct efi_device_path_vendor),
+			   &end_node, sizeof(struct efi_device_path));
+	ret = boottime->install_protocol_interface(&disk_handle,
+						   &guid_device_path,
+						   EFI_NATIVE_INTERFACE,
+						   dp);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("InstallProtocolInterface failed\n");
+		return EFI_ST_FAILURE;
+	}
+	return EFI_ST_SUCCESS;
+}
+
+/*
+ * Tear down unit test.
+ *
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int teardown(void)
+{
+	efi_status_t r = EFI_ST_SUCCESS;
+
+	if (disk_handle) {
+		r = boottime->uninstall_protocol_interface(disk_handle,
+							   &guid_device_path,
+							   dp);
+		if (r != EFI_SUCCESS) {
+			efi_st_error("UninstallProtocolInterface failed\n");
+			return EFI_ST_FAILURE;
+		}
+		r = boottime->uninstall_protocol_interface(
+				disk_handle, &block_io_protocol_guid,
+				&block_io);
+		if (r != EFI_SUCCESS) {
+			efi_st_error(
+				"Failed to uninstall block I/O protocol\n");
+			return EFI_ST_FAILURE;
+		}
+	}
+
+	if (image) {
+		r = efi_free_pool(image);
+		if (r != EFI_SUCCESS) {
+			efi_st_error("Failed to free image\n");
+			return EFI_ST_FAILURE;
+		}
+	}
+	return r;
+}
+
+/*
+ * Get length of device path without end tag.
+ *
+ * @dp		device path
+ * @return	length of device path in bytes
+ */
+static efi_uintn_t dp_size(struct efi_device_path *dp) {
+	struct efi_device_path *pos = dp;
+
+	while (pos->type != DEVICE_PATH_TYPE_END) {
+		pos = (struct efi_device_path *)((char *)pos + pos->length);
+	}
+	return (char *)pos - (char *)dp;
+}
+
+/*
+ * Execute unit test.
+ *
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int execute(void)
+{
+	efi_status_t ret;
+	efi_uintn_t no_handles, i, len;
+	efi_handle_t *handles;
+	efi_handle_t handle_partition = NULL;
+	struct efi_device_path *dp_partition;
+	struct efi_simple_file_system_protocol *file_system;
+	struct efi_file_handle *root, *file;
+	u64 buf_size;
+	char buf[16] __aligned(ARCH_DMA_MINALIGN);
+
+	ret = boottime->connect_controller(disk_handle, NULL, NULL, 1);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to connect controller\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = boottime->locate_handle_buffer(
+				BY_PROTOCOL, &guid_device_path, NULL,
+				&no_handles, &handles);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to locate handles\n");
+		return EFI_ST_FAILURE;
+	}
+	len = dp_size(dp);
+	for (i = 0; i < no_handles; ++i) {
+		ret = boottime->open_protocol(handles[i], &guid_device_path,
+					      (void **)&dp_partition,
+					      NULL, NULL,
+					      EFI_OPEN_PROTOCOL_GET_PROTOCOL);
+		if (ret != EFI_SUCCESS) {
+			efi_st_error("Failed to open device path protocol\n");
+			return EFI_ST_FAILURE;
+		}
+		if (len >= dp_size(dp_partition))
+			continue;
+		if (efi_st_memcmp(dp, dp_partition, len))
+			continue;
+		handle_partition = handles[i];
+		break;
+	}
+	ret = boottime->free_pool(handles);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to free pool memory\n");
+		return EFI_ST_FAILURE;
+	}
+	if (!handle_partition) {
+		efi_st_error("Partition handle not found\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = boottime->open_protocol(handle_partition,
+				      &guid_simple_file_system_protocol,
+				      (void **)&file_system, NULL, NULL,
+				      EFI_OPEN_PROTOCOL_GET_PROTOCOL);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to open simple file system protocol\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = file_system->open_volume(file_system, &root);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to open volume\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = root->open(root, &file, (s16 *)L"hello.txt", EFI_FILE_MODE_READ,
+			 0);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to open file\n");
+		return EFI_ST_FAILURE;
+	}
+	buf_size = sizeof(buf) - 1;
+	ret = file->read(file, &buf_size, buf);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to read file\n");
+		return EFI_ST_FAILURE;
+	}
+	if (efi_st_memcmp(buf, "Hello world!", 12)) {
+		efi_st_error("Unexpected file content\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = file->close(file);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to close file\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = root->close(root);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Failed to close volume\n");
+		return EFI_ST_FAILURE;
+	}
+
+	return EFI_ST_SUCCESS;
+}
+
+EFI_UNIT_TEST(blkdev) = {
+	.name = "block device",
+	.phase = EFI_EXECUTE_BEFORE_BOOTTIME_EXIT,
+	.setup = setup,
+	.execute = execute,
+	.teardown = teardown,
+};
diff --git a/lib/efi_selftest/efi_selftest_disk_image.h b/lib/efi_selftest/efi_selftest_disk_image.h
new file mode 100644
index 0000000000..4775dace70
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest_disk_image.h
@@ -0,0 +1,69 @@
+/*
+ *  Non-zero 8 byte strings of a disk image
+ *
+ *  Generated with tools/file2include
+ *
+ *  SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#define EFI_ST_DISK_IMG { 0x00010000, { \
+	{0x000001b8, "\x94\x37\x69\xfc\x00\x00\x00\x00"}, /* .7i..... */ \
+	{0x000001c0, "\x02\x00\x83\x02\x02\x00\x01\x00"}, /* ........ */ \
+	{0x000001c8, "\x00\x00\x7f\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x000001f8, "\x00\x00\x00\x00\x00\x00\x55\xaa"}, /* ......U. */ \
+	{0x00000200, "\xeb\x3c\x90\x6d\x6b\x66\x73\x2e"}, /* .<.mkfs. */ \
+	{0x00000208, "\x66\x61\x74\x00\x02\x04\x01\x00"}, /* fat..... */ \
+	{0x00000210, "\x02\x00\x02\x7f\x00\xf8\x01\x00"}, /* ........ */ \
+	{0x00000218, "\x20\x00\x40\x00\x00\x00\x00\x00"}, /*  .@..... */ \
+	{0x00000220, "\x00\x00\x00\x00\x80\x00\x29\x86"}, /* ......). */ \
+	{0x00000228, "\xe8\x82\x80\x4e\x4f\x20\x4e\x41"}, /* ...NO NA */ \
+	{0x00000230, "\x4d\x45\x20\x20\x20\x20\x46\x41"}, /* ME    FA */ \
+	{0x00000238, "\x54\x31\x32\x20\x20\x20\x0e\x1f"}, /* T12   .. */ \
+	{0x00000240, "\xbe\x5b\x7c\xac\x22\xc0\x74\x0b"}, /* .[|.".t. */ \
+	{0x00000248, "\x56\xb4\x0e\xbb\x07\x00\xcd\x10"}, /* V....... */ \
+	{0x00000250, "\x5e\xeb\xf0\x32\xe4\xcd\x16\xcd"}, /* ^..2.... */ \
+	{0x00000258, "\x19\xeb\xfe\x54\x68\x69\x73\x20"}, /* ...This  */ \
+	{0x00000260, "\x69\x73\x20\x6e\x6f\x74\x20\x61"}, /* is not a */ \
+	{0x00000268, "\x20\x62\x6f\x6f\x74\x61\x62\x6c"}, /*  bootabl */ \
+	{0x00000270, "\x65\x20\x64\x69\x73\x6b\x2e\x20"}, /* e disk.  */ \
+	{0x00000278, "\x20\x50\x6c\x65\x61\x73\x65\x20"}, /*  Please  */ \
+	{0x00000280, "\x69\x6e\x73\x65\x72\x74\x20\x61"}, /* insert a */ \
+	{0x00000288, "\x20\x62\x6f\x6f\x74\x61\x62\x6c"}, /*  bootabl */ \
+	{0x00000290, "\x65\x20\x66\x6c\x6f\x70\x70\x79"}, /* e floppy */ \
+	{0x00000298, "\x20\x61\x6e\x64\x0d\x0a\x70\x72"}, /*  and..pr */ \
+	{0x000002a0, "\x65\x73\x73\x20\x61\x6e\x79\x20"}, /* ess any  */ \
+	{0x000002a8, "\x6b\x65\x79\x20\x74\x6f\x20\x74"}, /* key to t */ \
+	{0x000002b0, "\x72\x79\x20\x61\x67\x61\x69\x6e"}, /* ry again */ \
+	{0x000002b8, "\x20\x2e\x2e\x2e\x20\x0d\x0a\x00"}, /*  ... ... */ \
+	{0x000003f8, "\x00\x00\x00\x00\x00\x00\x55\xaa"}, /* ......U. */ \
+	{0x00000400, "\xf8\xff\xff\x00\x00\x00\x00\xf0"}, /* ........ */ \
+	{0x00000408, "\xff\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00000600, "\xf8\xff\xff\x00\x00\x00\x00\xf0"}, /* ........ */ \
+	{0x00000608, "\xff\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00000800, "\xe5\x70\x00\x00\x00\xff\xff\xff"}, /* .p...... */ \
+	{0x00000808, "\xff\xff\xff\x0f\x00\x0e\xff\xff"}, /* ........ */ \
+	{0x00000810, "\xff\xff\xff\xff\xff\xff\xff\xff"}, /* ........ */ \
+	{0x00000818, "\xff\xff\x00\x00\xff\xff\xff\xff"}, /* ........ */ \
+	{0x00000820, "\xe5\x2e\x00\x68\x00\x65\x00\x6c"}, /* ...h.e.l */ \
+	{0x00000828, "\x00\x6c\x00\x0f\x00\x0e\x6f\x00"}, /* .l....o. */ \
+	{0x00000830, "\x2e\x00\x74\x00\x78\x00\x74\x00"}, /* ..t.x.t. */ \
+	{0x00000838, "\x2e\x00\x00\x00\x73\x00\x77\x00"}, /* ....s.w. */ \
+	{0x00000840, "\xe5\x45\x4c\x4c\x4f\x54\x7e\x31"}, /* .ELLOT~1 */ \
+	{0x00000848, "\x53\x57\x50\x20\x00\x64\xd0\x8a"}, /* SWP .d.. */ \
+	{0x00000850, "\x92\x4b\x92\x4b\x00\x00\xd0\x8a"}, /* .K.K.... */ \
+	{0x00000858, "\x92\x4b\x00\x00\x00\x00\x00\x00"}, /* .K...... */ \
+	{0x00000860, "\x41\x68\x00\x65\x00\x6c\x00\x6c"}, /* Ah.e.l.l */ \
+	{0x00000868, "\x00\x6f\x00\x0f\x00\xf1\x2e\x00"}, /* .o...... */ \
+	{0x00000870, "\x74\x00\x78\x00\x74\x00\x00\x00"}, /* t.x.t... */ \
+	{0x00000878, "\xff\xff\x00\x00\xff\xff\xff\xff"}, /* ........ */ \
+	{0x00000880, "\x48\x45\x4c\x4c\x4f\x20\x20\x20"}, /* HELLO    */ \
+	{0x00000888, "\x54\x58\x54\x20\x00\x64\xd4\x8a"}, /* TXT .d.. */ \
+	{0x00000890, "\x92\x4b\x92\x4b\x00\x00\xd4\x8a"}, /* .K.K.... */ \
+	{0x00000898, "\x92\x4b\x05\x00\x0d\x00\x00\x00"}, /* .K...... */ \
+	{0x000008a0, "\xe5\x45\x4c\x4c\x4f\x54\x7e\x31"}, /* .ELLOT~1 */ \
+	{0x000008a8, "\x53\x57\x58\x20\x00\x64\xd0\x8a"}, /* SWX .d.. */ \
+	{0x000008b0, "\x92\x4b\x92\x4b\x00\x00\xd0\x8a"}, /* .K.K.... */ \
+	{0x000008b8, "\x92\x4b\x00\x00\x00\x00\x00\x00"}, /* .K...... */ \
+	{0x00006000, "\x48\x65\x6c\x6c\x6f\x20\x77\x6f"}, /* Hello wo */ \
+	{0x00006008, "\x72\x6c\x64\x21\x0a\x00\x00\x00"}, /* rld!.... */ \
+	{0, NULL} } }
-- 
2.14.2

