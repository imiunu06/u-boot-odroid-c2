From 80c1dceacb0664eb8b5de2ad06627cb28e9cc111 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 5 Oct 2017 21:19:36 +0200
Subject: [PATCH 1/1] efi_selftest: test reboot by watchdog

A test is added that verifies that the watchdog timer actually
causes a reboot upon timeout. The test is only executed on
request using

    setenv efi_selftest watchdog reboot  
    bootefi selftest

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_selftest/efi_selftest_watchdog.c | 65 +++++++++++++++++++++++++++-----
 1 file changed, 55 insertions(+), 10 deletions(-)

diff --git a/lib/efi_selftest/efi_selftest_watchdog.c b/lib/efi_selftest/efi_selftest_watchdog.c
index f8c5404000..a2c11ab1b9 100644
--- a/lib/efi_selftest/efi_selftest_watchdog.c
+++ b/lib/efi_selftest/efi_selftest_watchdog.c
@@ -5,11 +5,15 @@
  *
  * SPDX-License-Identifier:     GPL-2.0+
  *
- * This unit test checks that the watchdog timer will not cause
- * a system restart during the timeout period after a timer reset.
+ * The 'watchdog timer' unit test checks that the watchdog timer
+ * will not cause a system restart during the timeout period after
+ * a timer reset.
  *
- * Testing that the watchdog timer actually will reset the system
- * after a timeout is not possible within the used framework.
+ * The 'watchdog reboot' unit test checks that the watchdog timer
+ * actually reboots the system after a timeout. The test is only
+ * executed on explicit request. Use the following command:
+ *
+ *     bootefi selftest 'watchdog reboot'
  */
 
 #include <efi_selftest.h>
@@ -28,6 +32,7 @@ static struct efi_event *event_notify;
 static struct efi_event *event_wait;
 static struct efi_boot_services *boottime;
 static struct notify_context notification_context;
+static bool watchdog_reset;
 
 /*
  * Notification function, increments the notfication count if parameter
@@ -88,6 +93,34 @@ static int setup(const efi_handle_t handle,
 	return EFI_ST_SUCCESS;
 }
 
+/*
+ * Execute the test resetting the watchdog in a timely manner. No reboot occurs.
+ *
+ * @handle:	handle of the loaded image
+ * @systable:	system table
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int setup_timer(const efi_handle_t handle,
+		       const struct efi_system_table *systable)
+{
+	watchdog_reset = true;
+	return setup(handle, systable);
+}
+
+/*
+ * Execute the test without resetting the watchdog. A system reboot occurs.
+ *
+ * @handle:	handle of the loaded image
+ * @systable:	system table
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int setup_reboot(const efi_handle_t handle,
+			const struct efi_system_table *systable)
+{
+	watchdog_reset = false;
+	return setup(handle, systable);
+}
+
 /*
  * Tear down unit test.
  *
@@ -146,11 +179,14 @@ static int execute(void)
 		efi_st_error("Setting watchdog timer failed\n");
 		return EFI_ST_FAILURE;
 	}
+	if (watchdog_reset) {
 	/* Set 600 ms timer */
-	ret = boottime->set_timer(event_notify, EFI_TIMER_PERIODIC, 6000000);
-	if (ret != EFI_SUCCESS) {
-		efi_st_error("Could not set timer\n");
-		return EFI_ST_FAILURE;
+		ret = boottime->set_timer(event_notify, EFI_TIMER_PERIODIC,
+					  6000000);
+		if (ret != EFI_SUCCESS) {
+			efi_st_error("Could not set timer\n");
+			return EFI_ST_FAILURE;
+		}
 	}
 	/* Set 1350 ms timer */
 	ret = boottime->set_timer(event_wait, EFI_TIMER_RELATIVE, 13500000);
@@ -176,10 +212,19 @@ static int execute(void)
 	return EFI_ST_SUCCESS;
 }
 
-EFI_UNIT_TEST(watchdog) = {
+EFI_UNIT_TEST(watchdog1) = {
 	.name = "watchdog timer",
 	.phase = EFI_EXECUTE_BEFORE_BOOTTIME_EXIT,
-	.setup = setup,
+	.setup = setup_timer,
+	.execute = execute,
+	.teardown = teardown,
+};
+
+EFI_UNIT_TEST(watchdog2) = {
+	.name = "watchdog reboot",
+	.phase = EFI_EXECUTE_BEFORE_BOOTTIME_EXIT,
+	.setup = setup_reboot,
 	.execute = execute,
 	.teardown = teardown,
+	.on_request = true,
 };
-- 
2.14.1

