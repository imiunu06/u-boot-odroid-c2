From a9d70ed4b7578e9d8b0f3a4fc5fa5401bfdac376 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 5 Oct 2017 16:02:07 +0200
Subject: [PATCH 1/1] efi_loader: replace efi_div10 by do_div

We should use the existing 64bit division instead of
reinventing the wheel.

Cc: Alexander Graf <agraf@suse.de>
Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
v2
	replace efi_div10 by do_div as suggested by Alex
v1
	replace efi_div10 by div_u64
---
 lib/efi_loader/efi_boottime.c | 36 ++----------------------------------
 1 file changed, 2 insertions(+), 34 deletions(-)

diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index df75dd9032..66ce92f654 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -7,6 +7,7 @@
  */
 
 #include <common.h>
+#include <div64.h>
 #include <efi_loader.h>
 #include <environment.h>
 #include <malloc.h>
@@ -128,39 +129,6 @@ const char *__efi_nesting_dec(void)
 	return indent_string(--nesting_level);
 }
 
-/* Low 32 bit */
-#define EFI_LOW32(a) (a & 0xFFFFFFFFULL)
-/* High 32 bit */
-#define EFI_HIGH32(a) (a >> 32)
-
-/*
- * 64bit division by 10 implemented as multiplication by 1 / 10
- *
- * Decimals of one tenth: 0x1 / 0xA = 0x0.19999...
- */
-#define EFI_TENTH 0x199999999999999A
-static u64 efi_div10(u64 a)
-{
-	u64 prod;
-	u64 rem;
-	u64 ret;
-
-	ret  = EFI_HIGH32(a) * EFI_HIGH32(EFI_TENTH);
-	prod = EFI_HIGH32(a) * EFI_LOW32(EFI_TENTH);
-	rem  = EFI_LOW32(prod);
-	ret += EFI_HIGH32(prod);
-	prod = EFI_LOW32(a) * EFI_HIGH32(EFI_TENTH);
-	rem += EFI_LOW32(prod);
-	ret += EFI_HIGH32(prod);
-	prod = EFI_LOW32(a) * EFI_LOW32(EFI_TENTH);
-	rem += EFI_HIGH32(prod);
-	ret += EFI_HIGH32(rem);
-	/* Round to nearest integer */
-	if (rem >= (1 << 31))
-		++ret;
-	return ret;
-}
-
 /*
  * Queue an EFI event.
  *
@@ -523,7 +491,7 @@ efi_status_t efi_set_timer(struct efi_event *event, enum efi_timer_delay type,
 	 * The parameter defines a multiple of 100ns.
 	 * We use multiples of 1000ns. So divide by 10.
 	 */
-	trigger_time = efi_div10(trigger_time);
+	do_div(trigger_time, 10);
 
 	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
 		if (event != &efi_events[i])
-- 
2.14.1

