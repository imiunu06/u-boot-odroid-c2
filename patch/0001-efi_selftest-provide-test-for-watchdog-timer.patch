From 1c85d95ef58df31b352c9c45dd98d05c59edbaca Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 5 Oct 2017 18:04:54 +0200
Subject: [PATCH 1/1] efi_selftest: provide test for watchdog timer

The test verifies that resetting the watchdog timer ensures
that it is not called during the timeout period.

Testing that the watchdog timer actually executes a reset
would require a test outside the efi_selftest framework.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_selftest/Makefile                |   5 +-
 lib/efi_selftest/efi_selftest_watchdog.c | 186 +++++++++++++++++++++++++++++++
 2 files changed, 190 insertions(+), 1 deletion(-)
 create mode 100644 lib/efi_selftest/efi_selftest_watchdog.c

diff --git a/lib/efi_selftest/Makefile b/lib/efi_selftest/Makefile
index e446046e02..3e5c9a6d16 100644
--- a/lib/efi_selftest/Makefile
+++ b/lib/efi_selftest/Makefile
@@ -21,6 +21,8 @@ CFLAGS_efi_selftest_tpl.o := $(CFLAGS_EFI)
 CFLAGS_REMOVE_efi_selftest_tpl.o := $(CFLAGS_NON_EFI)
 CFLAGS_efi_selftest_util.o := $(CFLAGS_EFI)
 CFLAGS_REMOVE_efi_selftest_util.o := $(CFLAGS_NON_EFI)
+CFLAGS_efi_selftest_watchdog.o := $(CFLAGS_EFI)
+CFLAGS_REMOVE_efi_selftest_watchdog.o := $(CFLAGS_NON_EFI)
 
 obj-$(CONFIG_CMD_BOOTEFI_SELFTEST) += \
 efi_selftest.o \
@@ -29,4 +31,5 @@ efi_selftest_events.o \
 efi_selftest_exitbootservices.o \
 efi_selftest_snp.o \
 efi_selftest_tpl.o \
-efi_selftest_util.o
+efi_selftest_util.o \
+efi_selftest_watchdog.o
diff --git a/lib/efi_selftest/efi_selftest_watchdog.c b/lib/efi_selftest/efi_selftest_watchdog.c
new file mode 100644
index 0000000000..6965bc77d1
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest_watchdog.c
@@ -0,0 +1,185 @@
+/*
+ * efi_selftest_watchdog
+ *
+ * Copyright (c) 2017 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ *
+ * This unit test checks that the watchdog timer will not cause
+ * a system restart during the timeout period after a timer reset.
+ *
+ * Testing that the watchdog timer actually will reset the system
+ * after a timeout is not possible within the used framework.
+ */
+
+#include <efi_selftest.h>
+
+/*
+ * This is the communication structure for the notification function.
+ */
+struct notify_context {
+	/* Status code returned when resetting watchdog */
+	efi_status_t status;
+	/* Number of invocations of the notification function */
+	unsigned int timer_ticks;
+};
+
+static struct efi_event *event_notify;
+static struct efi_event *event_wait;
+static struct efi_boot_services *boottime;
+static struct notify_context notification_context;
+
+/*
+ * Notification function, increments the notfication count if parameter
+ * context is provided.
+ *
+ * @event	notified event
+ * @context	pointer to the timeout
+ */
+static void EFIAPI notify(struct efi_event *event, void *context)
+{
+	struct notify_context *notify_context = context;
+	efi_status_t ret = EFI_SUCCESS;
+
+	if (!notify_context)
+		return;
+
+	/* Reset watchdog timer to one second */
+	ret = boottime->set_watchdog_timer(1, 0, 0, NULL);
+	if (ret != EFI_SUCCESS)
+		notify_context->status = ret;
+	/* Count number of calls */
+	notify_context->timer_ticks++;
+}
+
+/*
+ * Setup unit test.
+ *
+ * Create two timer events.
+ * One with EVT_NOTIFY_SIGNAL, the other with EVT_NOTIFY_WAIT.
+ *
+ * @handle:	handle of the loaded image
+ * @systable:	system table
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int setup(const efi_handle_t handle,
+		 const struct efi_system_table *systable)
+{
+	efi_status_t ret;
+
+	boottime = systable->boottime;
+
+	notification_context.status = EFI_SUCCESS;
+	notification_context.timer_ticks = 0;
+	ret = boottime->create_event(EVT_TIMER | EVT_NOTIFY_SIGNAL,
+				     TPL_CALLBACK, notify,
+				     (void *)&notification_context,
+				     &event_notify);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("could not create event\n");
+		return EFI_ST_FAILURE;
+	}
+	ret = boottime->create_event(EVT_TIMER | EVT_NOTIFY_WAIT,
+				     TPL_CALLBACK, notify, NULL, &event_wait);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("could not create event\n");
+		return EFI_ST_FAILURE;
+	}
+	return EFI_ST_SUCCESS;
+}
+
+/*
+ * Tear down unit test.
+ *
+ * Close the events created in setup.
+ *
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int teardown(void)
+{
+	efi_status_t ret;
+
+	/* Set the watchdog timer to the five minute default value */
+	ret = boottime->set_watchdog_timer(300, 0, 0, NULL);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Setting watchdog timer failed\n");
+		return EFI_ST_FAILURE;
+	}
+	if (event_notify) {
+		ret = boottime->close_event(event_notify);
+		event_notify = NULL;
+		if (ret != EFI_SUCCESS) {
+			efi_st_error("Could not close event\n");
+			return EFI_ST_FAILURE;
+		}
+	}
+	if (event_wait) {
+		ret = boottime->close_event(event_wait);
+		event_wait = NULL;
+		if (ret != EFI_SUCCESS) {
+			efi_st_error("Could not close event\n");
+			return EFI_ST_FAILURE;
+		}
+	}
+	return EFI_ST_SUCCESS;
+}
+
+/*
+ * Execute unit test.
+ *
+ * Run a 600 ms periodic timer that resets the watchdog to one second
+ * on every timer tick.
+ *
+ * Run a 1350 ms single shot timer and check that the 600ms timer has
+ * been called 2 times.
+ *
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int execute(void)
+{
+	size_t index;
+	efi_status_t ret;
+
+	/* Set the watchdog timeout to one second */
+	ret = boottime->set_watchdog_timer(1, 0, 0, NULL);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Setting watchdog timer failed\n");
+		return EFI_ST_FAILURE;
+	}
+	/* Set 600 ms timer */
+	ret = boottime->set_timer(event_notify, EFI_TIMER_PERIODIC, 6000000);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Could not set timer\n");
+		return EFI_ST_FAILURE;
+	}
+	/* Set 1350 ms timer */
+	ret = boottime->set_timer(event_wait, EFI_TIMER_RELATIVE, 13500000);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Could not set timer\n");
+		return EFI_ST_FAILURE;
+	}
+
+	ret = boottime->wait_for_event(1, &event_wait, &index);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Could not wait for event\n");
+		return EFI_ST_FAILURE;
+	}
+	if (notification_context.status != EFI_SUCCESS) {
+		efi_st_error("Setting watchdog timer failed\n");
+		return EFI_ST_FAILURE;
+	}
+	if (notification_context.timer_ticks != 2) {
+		efi_st_error("The timer was called %u times, expected 2.\n",
+			     notification_context.timer_ticks);
+		return EFI_ST_FAILURE;
+	}
+	return EFI_ST_SUCCESS;
+}
+
+EFI_UNIT_TEST(watchdog) = {
+	.name = "watchdog timer",
+	.phase = EFI_EXECUTE_BEFORE_BOOTTIME_EXIT,
+	.setup = setup,
+	.execute = execute,
+	.teardown = teardown,
+};
-- 
2.14.1

