From 1247255615d045dd50d21d1d082a86c121d69a83 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 2 Jul 2017 19:11:30 +0200
Subject: [PATCH 1/1] efi_loader: implement WaitForKey

The EFI_SIMPLE_TEXT_INPUT_PROTOCOL requires an event WaitForKey.

We can easily signal the event in the efi_timer_check function.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h          |  2 +-
 lib/efi_loader/efi_boottime.c | 19 +++++++++++++++----
 lib/efi_loader/efi_console.c  |  2 +-
 3 files changed, 17 insertions(+), 6 deletions(-)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index 77081eda3d..c7055deb00 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -92,7 +92,7 @@ struct efi_event {
 	enum efi_event_type trigger_type;
 	int signaled;
 };
-
+extern struct efi_event efi_events[];
 
 /* This list contains all UEFI objects we know of */
 extern struct list_head efi_obj_list;
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index a194dd7906..0f41795795 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -164,7 +164,13 @@ static efi_status_t EFIAPI efi_free_pool_ext(void *buffer)
  * Our event capabilities are very limited. Only a small limited
  * number of events is allowed to coexist.
  */
-static struct efi_event efi_events[4];
+struct efi_event efi_events[4] = {
+	{
+		/* WaitForKey */
+		.type = EVT_NOTIFY_WAIT,
+		.trigger_next = -1ULL,
+	}
+};
 
 static efi_status_t EFIAPI efi_create_event(
 			enum efi_event_type type, ulong notify_tpl,
@@ -186,7 +192,8 @@ static efi_status_t EFIAPI efi_create_event(
 	     notify_function == NULL)
 		return EFI_EXIT(EFI_INVALID_PARAMETER);
 
-	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
+	/* Use first empty slot */
+	for (i = 1; i < ARRAY_SIZE(efi_events); ++i) {
 		if (efi_events[i].type)
 			continue;
 		efi_events[i].type = type;
@@ -211,7 +218,11 @@ void efi_timer_check(void)
 	int i;
 	u64 now = timer_get_us();
 
-	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
+	/* Signal keystroke */
+	if (tstc())
+		efi_events[0].signaled = 1;
+
+	for (i = 1; i < ARRAY_SIZE(efi_events); ++i) {
 		if (!(efi_events[i].type & EVT_TIMER) ||
 		    now < efi_events[i].trigger_next)
 			continue;
@@ -313,7 +324,7 @@ static efi_status_t EFIAPI efi_close_event(void *event)
 	int i;
 
 	EFI_ENTRY("%p", event);
-	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
+	for (i = 1; i < ARRAY_SIZE(efi_events); ++i) {
 		if (event != &efi_events[i])
 			continue;
 		efi_events[i].type = 0;
diff --git a/lib/efi_loader/efi_console.c b/lib/efi_loader/efi_console.c
index 8ef7326fef..2a01367e42 100644
--- a/lib/efi_loader/efi_console.c
+++ b/lib/efi_loader/efi_console.c
@@ -424,5 +424,5 @@ static efi_status_t EFIAPI efi_cin_read_key_stroke(
 const struct efi_simple_input_interface efi_con_in = {
 	.reset = efi_cin_reset,
 	.read_key_stroke = efi_cin_read_key_stroke,
-	.wait_for_key = NULL,
+	.wait_for_key = &efi_events[0],
 };
-- 
2.11.0

