From c69ad8f36ce3e0b230e5c37239cf900ac4efdcb1 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Mon, 17 Jul 2017 18:51:42 +0200
Subject: [PATCH 1/1] efi_loader: refactor efi_create_event

efi_create_event is refactored to make it possible to call it
internally. For EFI applications wrapper function
efi_create_event_ext is created.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_boottime.c | 28 ++++++++++++++++++++--------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index d5c68309be..6b4a7bf514 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -189,17 +189,15 @@ static efi_status_t EFIAPI efi_create_event(
 {
 	int i;
 
-	EFI_ENTRY("%d, 0x%lx, %p, %p", type, notify_tpl, notify_function,
-		  notify_context);
 	if (event == NULL)
-		return EFI_EXIT(EFI_INVALID_PARAMETER);
+		return EFI_INVALID_PARAMETER;
 
 	if ((type & EVT_NOTIFY_SIGNAL) && (type & EVT_NOTIFY_WAIT))
-		return EFI_EXIT(EFI_INVALID_PARAMETER);
+		return EFI_INVALID_PARAMETER;
 
 	if ((type & (EVT_NOTIFY_SIGNAL|EVT_NOTIFY_WAIT)) &&
 	    notify_function == NULL)
-		return EFI_EXIT(EFI_INVALID_PARAMETER);
+		return EFI_INVALID_PARAMETER;
 
 	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
 		if (efi_events[i].type)
@@ -212,11 +210,25 @@ static efi_status_t EFIAPI efi_create_event(
 		efi_events[i].trigger_next = -1ULL;
 		efi_events[i].signaled = 0;
 		*event = &efi_events[i];
-		return EFI_EXIT(EFI_SUCCESS);
+		return EFI_SUCCESS;
 	}
-	return EFI_EXIT(EFI_OUT_OF_RESOURCES);
+	return EFI_OUT_OF_RESOURCES;
+}
+
+static efi_status_t EFIAPI efi_create_event_ext(
+			enum efi_event_type type, ulong notify_tpl,
+			void (EFIAPI *notify_function) (
+					struct efi_event *event,
+					void *context),
+			void *notify_context, struct efi_event **event)
+{
+	EFI_ENTRY("%d, 0x%lx, %p, %p", type, notify_tpl, notify_function,
+		  notify_context);
+	return EFI_EXIT(efi_create_event(type, notify_tpl, notify_function,
+					 notify_context, event));
 }
 
+
 /*
  * Our timers have to work without interrupts, so we check whenever keyboard
  * input or disk accesses happen if enough time elapsed for it to fire.
@@ -1096,7 +1108,7 @@ static const struct efi_boot_services efi_boot_services = {
 	.get_memory_map = efi_get_memory_map_ext,
 	.allocate_pool = efi_allocate_pool_ext,
 	.free_pool = efi_free_pool_ext,
-	.create_event = efi_create_event,
+	.create_event = efi_create_event_ext,
 	.set_timer = efi_set_timer,
 	.wait_for_event = efi_wait_for_event,
 	.signal_event = efi_signal_event_ext,
-- 
2.13.2

