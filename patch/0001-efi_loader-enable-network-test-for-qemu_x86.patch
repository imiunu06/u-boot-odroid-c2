From 9da72da401df5ff2c19593d1d437ed6bd3a3197f Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sat, 23 Sep 2017 14:17:40 +0200
Subject: [PATCH 1/1] efi_loader: enable network test for qemu_x86

Set
CONFIG_CMD_BOOTEFI_NETWORK_TEST=y
for qemu-x86_defconfig and qemu-x86_64_defconfig

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 configs/qemu-x86_64_defconfig     |  1 +
 configs/qemu-x86_defconfig        |  1 +
 lib/efi_loader/efi_network_test.c | 85 ++++++++++++++++++++++++++-------------
 3 files changed, 60 insertions(+), 27 deletions(-)

diff --git a/configs/qemu-x86_64_defconfig b/configs/qemu-x86_64_defconfig
index c3751fe24d..350cbfbeb1 100644
--- a/configs/qemu-x86_64_defconfig
+++ b/configs/qemu-x86_64_defconfig
@@ -66,3 +66,4 @@ CONFIG_FRAMEBUFFER_SET_VESA_MODE=y
 CONFIG_FRAMEBUFFER_VESA_MODE_111=y
 CONFIG_CONSOLE_SCROLL_LINES=5
 CONFIG_CMD_BOOTEFI_SELFTEST=y
+CONFIG_CMD_BOOTEFI_NETWORK_TEST=y
diff --git a/configs/qemu-x86_defconfig b/configs/qemu-x86_defconfig
index 60c2e3c404..a959f18a5a 100644
--- a/configs/qemu-x86_defconfig
+++ b/configs/qemu-x86_defconfig
@@ -46,3 +46,4 @@ CONFIG_FRAMEBUFFER_SET_VESA_MODE=y
 CONFIG_FRAMEBUFFER_VESA_MODE_111=y
 CONFIG_CONSOLE_SCROLL_LINES=5
 CONFIG_CMD_BOOTEFI_SELFTEST=y
+CONFIG_CMD_BOOTEFI_NETWORK_TEST=y
diff --git a/lib/efi_loader/efi_network_test.c b/lib/efi_loader/efi_network_test.c
index 6ada9f9887..ee3ef995d9 100644
--- a/lib/efi_loader/efi_network_test.c
+++ b/lib/efi_loader/efi_network_test.c
@@ -9,6 +9,11 @@
 
 #include <efi_selftest.h>
 
+/*
+ * MAC address for broadcasts
+ */
+static const u8 BROADCAST_MAC[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
 struct dhcp_hdr {
 	u8 op;
 #define BOOTREQUEST 1
@@ -30,14 +35,14 @@ struct dhcp_hdr {
 	u8 file[128];
 };
 
-#define DHCP_MESSAGE_TYPE 0x35
-#define DHCPDISCOVER	1
-#define DHCPOFFER	2
-#define DHCPREQUEST	3
-#define DHCPDECLINE	4
-#define DHCPACK		5
-#define DHCPNAK		6
-#define DHCPRELEASE	7
+#define DHCP_MESSAGE_TYPE	0x35
+#define DHCPDISCOVER		1
+#define DHCPOFFER		2
+#define DHCPREQUEST		3
+#define DHCPDECLINE		4
+#define DHCPACK			5
+#define DHCPNAK			6
+#define DHCPRELEASE		7
 
 struct dhcp {
 	struct ethernet_hdr eth_hdr;
@@ -53,7 +58,13 @@ static const efi_guid_t efi_net_guid = EFI_SIMPLE_NETWORK_GUID;
 /* IP packet ID */
 static unsigned net_ip_id;
 
-#include "../../lib/efi_selftest/efi_selftest_console.c"
+/*
+ * We cannot reuse the object files because EFI apps are
+ * built with other CFLAGS than the rest of the code.
+ * So let's simply include the sources.
+ */
+#include "../lib/efi_selftest/efi_selftest_console.c"
+#include "../net/checksum.c"
 
 void *memset(void *s, int c, size_t n)
 {
@@ -65,7 +76,8 @@ void *memset(void *s, int c, size_t n)
 	return s;
 }
 
-int memcmp(const void *s1, const void *s2, size_t n) {
+int memcmp(const void *s1, const void *s2, size_t n)
+{
 	const u8 *pos1 = s1;
 	const u8 *pos2 = s2;
 
@@ -78,7 +90,8 @@ int memcmp(const void *s1, const void *s2, size_t n) {
 	return 0;
 }
 
-void *memcpy(void *d, const void *s, size_t n) {
+void *memcpy(void *d, const void *s, size_t n)
+{
 	const char *poss = s;
 	char *posd = d;
 
@@ -95,7 +108,7 @@ efi_status_t send_dhcp_request(void)
 	/*
 	 * Fill ethernet header
 	 */
-	memset(p.eth_hdr.et_dest, 0xff, ARP_HLEN);
+	memcpy(p.eth_hdr.et_dest, BROADCAST_MAC, ARP_HLEN);
 	memcpy(p.eth_hdr.et_src, &net->mode->current_address, ARP_HLEN);
 	p.eth_hdr.et_protlen = htons(PROT_IP);
 	/*
@@ -110,6 +123,8 @@ efi_status_t send_dhcp_request(void)
 	p.ip_udp.ip_ttl		= 0xff; /* time to live */
 	p.ip_udp.ip_p		= IPPROTO_UDP;
 	p.ip_udp.ip_sum		= 0;
+	p.ip_udp.ip_sum = compute_ip_checksum(&p.ip_udp, IP_HDR_SIZE);
+
 	/*
 	 * Fill UDP header
 	 */
@@ -130,14 +145,18 @@ efi_status_t send_dhcp_request(void)
 	/*
 	 * Fill options
 	 */
-	p.opt[0] = 0x63; /* Magic cookie */
-	p.opt[1] = 0x82;
-	p.opt[2] = 0x53;
-	p.opt[3] = 0x63;
-	p.opt[4] = DHCP_MESSAGE_TYPE;
-	p.opt[5] = 0x01; /* length */
-	p.opt[6] = DHCPDISCOVER;
-	p.opt[7] = 0xff;
+	p.opt[0] 	= 0x63; /* DHCP magic cookie */
+	p.opt[1] 	= 0x82;
+	p.opt[2] 	= 0x53;
+	p.opt[3] 	= 0x63;
+	p.opt[4] 	= DHCP_MESSAGE_TYPE;
+	p.opt[5] 	= 0x01; /* length */
+	p.opt[6] 	= DHCPDISCOVER;
+	p.opt[7] 	= 0x39; /* maximum message size */
+	p.opt[8] 	= 0x02; /* length */
+	p.opt[9] 	= 0x02; /* 576 bytes */
+	p.opt[10] 	= 0x40;
+	p.opt[11] 	= 0xff; /* end of options */
 
 	return net->transmit(net, 0, sizeof(struct dhcp), &p, NULL, NULL, 0);
 }
@@ -156,6 +175,7 @@ efi_status_t EFIAPI efi_main(efi_handle_t handle,
 	struct efi_mac_address srcaddr;
 	struct efi_mac_address destaddr;
 	size_t buffer_size;
+	u8 *addr;
 
 	boottime = systable->boottime;
 	con_out = systable->con_out;
@@ -198,7 +218,7 @@ efi_status_t EFIAPI efi_main(efi_handle_t handle,
 	}
 	if (net->mode->hwaddr_size != ARP_HLEN) {
 		efi_st_error("HwAddressSize = %u, expected %u\n",
-			     net->mode->hwaddr_size, ARP_HLEN);
+		             net->mode->hwaddr_size, ARP_HLEN);
 		goto out;
 	}
 	if (!net->wait_for_packet) {
@@ -243,7 +263,7 @@ efi_status_t EFIAPI efi_main(efi_handle_t handle,
 			ret = send_dhcp_request();
 			if (ret != EFI_SUCCESS) {
 				efi_st_error("Sending an DHCP request "
-					     "failed\n");
+				             "failed\n");
 				goto out;
 			}
 			efi_st_printf("DHCP Discover\n");
@@ -251,13 +271,18 @@ efi_status_t EFIAPI efi_main(efi_handle_t handle,
 		}
 		buffer_size = sizeof(buffer);
 		net->receive(net, NULL, &buffer_size, &buffer,
-			     &srcaddr, &destaddr, NULL);
+		             &srcaddr, &destaddr, NULL);
 		if (ret != EFI_SUCCESS) {
 			efi_st_error("Failed to receive packet");
 			goto out;
 		}
-		/* Check the packet is meant for this system */
-		if (memcmp(&destaddr, &net->mode->current_address, ARP_HLEN))
+		/*
+		 * Check the packet is meant for this system.
+		 * Unfortunately QEMU ignores the broadcast flag.
+		 * So we have to check for broadcasts too.
+		 */
+		if (memcmp(&destaddr, &net->mode->current_address, ARP_HLEN) &&
+		    memcmp(&destaddr, BROADCAST_MAC, ARP_HLEN))
 			continue;
 		/* Check this is a DHCP reply */
 		if (buffer.p.eth_hdr.et_protlen != ntohs(PROT_IP) ||
@@ -267,7 +292,13 @@ efi_status_t EFIAPI efi_main(efi_handle_t handle,
 		    buffer.p.ip_udp.udp_dst != ntohs(68) ||
 		    buffer.p.dhcp_hdr.op != BOOTREPLY)
 			continue;
-		efi_st_printf("DHCP reply received\n");
+		addr = (u8 *)&buffer.p.ip_udp.ip_src;
+		efi_st_printf("DHCP reply received from %u.%u.%u.%u (%pm) ",
+		              addr[0], addr[1], addr[2], addr[3], &srcaddr);
+		if (!memcmp(&destaddr, BROADCAST_MAC, ARP_HLEN))
+			efi_st_printf("as broadcast message.\n");
+		else
+			efi_st_printf("as unicast message.\n");
 		break;
 	}
 
@@ -311,7 +342,7 @@ out:
 	}
 
 	if (exit_status == EFI_SUCCESS)
-		efi_st_printf("The test ran successfully\n");
+		efi_st_printf("OK. The test was completed successfully.\n");
 
 	boottime->exit(handle, exit_status, 0, NULL);
 
-- 
2.11.0

