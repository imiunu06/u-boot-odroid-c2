From 3f00d75e79b1c4cab5e1ae7a9e1ce7450df53f15 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Wed, 4 Oct 2017 13:01:58 +0200
Subject: [PATCH 1/1] efi_loader: use type bool for event states

Queued and signaled describe boolean states of events.
So let's use type bool and rename the structure members to is_queued
and is_signaled.

Update the comments for is_queued and is_signaled.

Reported-by: Simon Glass <sjg@chromium.org>
Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h          |  8 ++++----
 lib/efi_loader/efi_boottime.c | 32 ++++++++++++++++----------------
 lib/efi_loader/efi_console.c  |  2 +-
 3 files changed, 21 insertions(+), 21 deletions(-)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index 2f081f8996..1148db2b00 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -136,8 +136,8 @@ struct efi_object {
  * @nofify_function:	Function to call when the event is triggered
  * @notify_context:	Data to be passed to the notify function
  * @trigger_type:	Type of timer, see efi_set_timer
- * @queued:		The notification functionis queued
- * @signaled:		The event occured
+ * @queued:		The notification function is queued
+ * @signaled:		The event occurred. The event is in the signaled state.
  */
 struct efi_event {
 	uint32_t type;
@@ -147,8 +147,8 @@ struct efi_event {
 	u64 trigger_next;
 	u64 trigger_time;
 	enum efi_timer_delay trigger_type;
-	int queued;
-	int signaled;
+	bool is_queued;
+	bool is_signaled;
 };
 
 
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index d63c66dd45..8975fc4ec1 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -132,14 +132,14 @@ const char *__efi_nesting_dec(void)
 void efi_signal_event(struct efi_event *event)
 {
 	if (event->notify_function) {
-		event->queued = 1;
+		event->is_queued = true;
 		/* Check TPL */
 		if (efi_tpl >= event->notify_tpl)
 			return;
 		EFI_CALL_VOID(event->notify_function(event,
 						     event->notify_context));
 	}
-	event->queued = 0;
+	event->is_queued = false;
 }
 
 static efi_status_t efi_unsupported(const char *funcname)
@@ -267,8 +267,8 @@ efi_status_t efi_create_event(uint32_t type, UINTN notify_tpl,
 		efi_events[i].notify_context = notify_context;
 		/* Disable timers on bootup */
 		efi_events[i].trigger_next = -1ULL;
-		efi_events[i].queued = 0;
-		efi_events[i].signaled = 0;
+		efi_events[i].is_queued = false;
+		efi_events[i].is_signaled = false;
 		*event = &efi_events[i];
 		return EFI_SUCCESS;
 	}
@@ -301,7 +301,7 @@ void efi_timer_check(void)
 	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
 		if (!efi_events[i].type)
 			continue;
-		if (efi_events[i].queued)
+		if (efi_events[i].is_queued)
 			efi_signal_event(&efi_events[i]);
 		if (!(efi_events[i].type & EVT_TIMER) ||
 		    now < efi_events[i].trigger_next)
@@ -317,7 +317,7 @@ void efi_timer_check(void)
 		default:
 			continue;
 		}
-		efi_events[i].signaled = 1;
+		efi_events[i].is_signaled = true;
 		efi_signal_event(&efi_events[i]);
 	}
 	WATCHDOG_RESET();
@@ -354,7 +354,7 @@ efi_status_t efi_set_timer(struct efi_event *event, enum efi_timer_delay type,
 		}
 		event->trigger_type = type;
 		event->trigger_time = trigger_time;
-		event->signaled = 0;
+		event->is_signaled = false;
 		return EFI_SUCCESS;
 	}
 	return EFI_INVALID_PARAMETER;
@@ -391,14 +391,14 @@ static efi_status_t EFIAPI efi_wait_for_event(unsigned long num_events,
 known_event:
 		if (!event[i]->type || event[i]->type & EVT_NOTIFY_SIGNAL)
 			return EFI_EXIT(EFI_INVALID_PARAMETER);
-		if (!event[i]->signaled)
+		if (!event[i]->is_signaled)
 			efi_signal_event(event[i]);
 	}
 
 	/* Wait for signal */
 	for (;;) {
 		for (i = 0; i < num_events; ++i) {
-			if (event[i]->signaled)
+			if (event[i]->is_signaled)
 				goto out;
 		}
 		/* Allow events to occur. */
@@ -410,7 +410,7 @@ out:
 	 * Reset the signal which is passed to the caller to allow periodic
 	 * events to occur.
 	 */
-	event[i]->signaled = 0;
+	event[i]->is_signaled = false;
 	if (index)
 		*index = i;
 
@@ -425,9 +425,9 @@ static efi_status_t EFIAPI efi_signal_event_ext(struct efi_event *event)
 	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
 		if (event != &efi_events[i])
 			continue;
-		if (event->signaled)
+		if (event->is_signaled)
 			break;
-		event->signaled = 1;
+		event->is_signaled = true;
 		if (event->type & EVT_NOTIFY_SIGNAL)
 			efi_signal_event(event);
 		break;
@@ -444,8 +444,8 @@ static efi_status_t EFIAPI efi_close_event(struct efi_event *event)
 		if (event == &efi_events[i]) {
 			event->type = 0;
 			event->trigger_next = -1ULL;
-			event->queued = 0;
-			event->signaled = 0;
+			event->is_queued = false;
+			event->is_signaled = false;
 			return EFI_EXIT(EFI_SUCCESS);
 		}
 	}
@@ -463,9 +463,9 @@ static efi_status_t EFIAPI efi_check_event(struct efi_event *event)
 			continue;
 		if (!event->type || event->type & EVT_NOTIFY_SIGNAL)
 			break;
-		if (!event->signaled)
+		if (!event->is_signaled)
 			efi_signal_event(event);
-		if (event->signaled)
+		if (event->is_signaled)
 			return EFI_EXIT(EFI_SUCCESS);
 		return EFI_EXIT(EFI_NOT_READY);
 	}
diff --git a/lib/efi_loader/efi_console.c b/lib/efi_loader/efi_console.c
index fd5398d61d..1bdf36b4ae 100644
--- a/lib/efi_loader/efi_console.c
+++ b/lib/efi_loader/efi_console.c
@@ -460,7 +460,7 @@ static void EFIAPI efi_console_timer_notify(struct efi_event *event,
 {
 	EFI_ENTRY("%p, %p", event, context);
 	if (tstc()) {
-		efi_con_in.wait_for_key->signaled = 1;
+		efi_con_in.wait_for_key->is_signaled = true;
 		efi_signal_event(efi_con_in.wait_for_key);
 		}
 	EFI_EXIT(EFI_SUCCESS);
-- 
2.14.1

