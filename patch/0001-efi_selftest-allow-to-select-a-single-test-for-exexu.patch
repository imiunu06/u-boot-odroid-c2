From 8782997af8482648345cfe6cfc46208d5b94c241 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Thu, 5 Oct 2017 20:56:03 +0200
Subject: [PATCH 1/1] efi_selftest: allow to select a single test for exexution

The second argument of bootefi is passed as a configuration
table to the selftest application. It is used to select
a single test to be executed.

Tests get an on_request property. If this property is set
the tests are only executed if explicitly requested.

A new command 'bootefi selftest list' is added that allows to list
all tests.

The invocation of efi_selftest is changed to reflect that
bootefi selftest list will call the Exit bootservice.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c                        | 43 +++++++++++++++++-
 include/efi_selftest.h               | 19 ++++++++
 lib/efi_selftest/efi_selftest.c      | 88 ++++++++++++++++++++++++++++++++++--
 lib/efi_selftest/efi_selftest_util.c |  9 ++++
 4 files changed, 153 insertions(+), 6 deletions(-)

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 24958ada46..92d8e1da05 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -10,6 +10,7 @@
 #include <command.h>
 #include <dm.h>
 #include <efi_loader.h>
+#include <efi_selftest.h>
 #include <errno.h>
 #include <libfdt.h>
 #include <libfdt_env.h>
@@ -50,6 +51,32 @@ static void efi_init_obj_list(void)
 	efi_get_time_init();
 }
 
+/*
+ * Set the load options of an image from an environment variable.
+ *
+ * @loaded_image_info:	the image
+ * @env_var:		name of the environment variable
+ */
+static void set_load_options(struct efi_loaded_image *loaded_image_info,
+			     const char *env_var)
+{
+	size_t size;
+	const char *env = env_get(env_var);
+
+	loaded_image_info->load_options = NULL;
+	loaded_image_info->load_options_size = 0;
+	if (!env)
+		return;
+	size = strlen(env) + 1;
+	loaded_image_info->load_options = calloc(size, sizeof(u16));
+	if (!loaded_image_info->load_options) {
+		printf("ERROR: Out of memory\n");
+		return;
+	}
+	utf8_to_utf16(loaded_image_info->load_options, env, size);
+	loaded_image_info->load_options_size = size * 2;
+}
+
 static void *copy_fdt(void *fdt)
 {
 	u64 fdt_size = fdt_totalsize(fdt);
@@ -275,20 +302,30 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if (!strcmp(argv[1], "selftest")) {
 		struct efi_loaded_image loaded_image_info = {};
 		struct efi_object loaded_image_info_obj = {};
+		char *test = NULL;
 
 		efi_setup_loaded_image(&loaded_image_info,
 				       &loaded_image_info_obj,
-				       bootefi_device_path, bootefi_image_path);
+				       NULL, NULL);
 		/*
 		 * gd lives in a fixed register which may get clobbered while we
 		 * execute the payload. So save it here and restore it on every
 		 * callback entry
 		 */
 		efi_save_gd();
+		loaded_image_info.image_code_type = EFI_LOADER_CODE;
+		loaded_image_info.image_data_type = EFI_LOADER_DATA;
 		/* Initialize and populate EFI object list */
 		if (!efi_obj_list_initalized)
 			efi_init_obj_list();
-		return efi_selftest(&loaded_image_info, &systab);
+		/* Transfer environment variable efi_selftest as load option */
+		set_load_options(&loaded_image_info, "efi_selftest");
+		loaded_image_info.load_options = test;
+		/* Execute the test */
+		r = efi_selftest(&loaded_image_info, &systab);
+		efi_restore_gd();
+		list_del(&loaded_image_info_obj.link);
+		return r;
 	} else
 #endif
 	if (!strcmp(argv[1], "bootmgr")) {
@@ -334,6 +371,8 @@ static char bootefi_help_text[] =
 #ifdef CONFIG_CMD_BOOTEFI_SELFTEST
 	"bootefi selftest\n"
 	"  - boot an EFI selftest application stored within U-Boot\n"
+	"    Use environment variable efi_selftest to select a single test.\n"
+	"    Use 'setenv efi_selftest list' to enumerate all tests.\n"
 #endif
 	"bootmgr [fdt addr]\n"
 	"  - load and boot EFI payload based on BootOrder/BootXXXX variables.\n"
diff --git a/include/efi_selftest.h b/include/efi_selftest.h
index 7ec42a0406..730b37303e 100644
--- a/include/efi_selftest.h
+++ b/include/efi_selftest.h
@@ -12,6 +12,7 @@
 #include <common.h>
 #include <efi.h>
 #include <efi_api.h>
+#include <efi_loader.h>
 #include <linker_lists.h>
 
 #define EFI_ST_SUCCESS 0
@@ -72,6 +73,16 @@ void efi_st_printf(const char *fmt, ...)
 int efi_st_memcmp(const void *buf1, const void *buf2, size_t length);
 
 /*
+ * Compare strings.
+ * We cannot use lib/string.c due to different CFLAGS values.
+ *
+ * @buf1:	first buffer
+ * @buf2:	second buffer
+ * @return:	0 if both buffers contain the same bytes
+ */
+int efi_st_strcmp(const char *buf1, const char *buf2);
+
+/*
  * Reads an Unicode character from the input device.
  *
  * @return: Unicode character
@@ -88,6 +99,7 @@ u16 efi_st_get_key(void);
  * @setup:	set up the unit test
  * @teardown:	tear down the unit test
  * @execute:	execute the unit test
+ * @on_request:	test is only executed on request
  */
 struct efi_unit_test {
 	const char *name;
@@ -96,10 +108,17 @@ struct efi_unit_test {
 		     const struct efi_system_table *systable);
 	int (*execute)(void);
 	int (*teardown)(void);
+	bool on_request;
 };
 
 /* Declare a new EFI unit test */
 #define EFI_UNIT_TEST(__name)						\
 	ll_entry_declare(struct efi_unit_test, __name, efi_unit_test)
 
+#define EFI_SELFTEST_TABLE_GUID \
+	EFI_GUID(0xbc3ebe57, 0x09e5, 0xa59d, 0xdb, 0x87, \
+		 0xf5, 0x79, 0x61, 0x62, 0x06, 0xde)
+
+extern const efi_guid_t efi_selftest_table_guid;
+
 #endif /* _EFI_SELFTEST_H */
diff --git a/lib/efi_selftest/efi_selftest.c b/lib/efi_selftest/efi_selftest.c
index 45d8d3d384..de8bc959ef 100644
--- a/lib/efi_selftest/efi_selftest.c
+++ b/lib/efi_selftest/efi_selftest.c
@@ -15,6 +15,8 @@ static const struct efi_runtime_services *runtime;
 static efi_handle_t handle;
 static u16 reset_message[] = L"Selftest completed";
 
+const efi_guid_t efi_selftest_table_guid = EFI_SELFTEST_TABLE_GUID;
+
 /*
  * Exit the boot services.
  *
@@ -25,8 +27,8 @@ static u16 reset_message[] = L"Selftest completed";
  */
 void efi_st_exit_boot_services(void)
 {
-	unsigned long  map_size = 0;
-	unsigned long  map_key;
+	unsigned long map_size = 0;
+	unsigned long map_key;
 	unsigned long desc_size;
 	u32 desc_version;
 	efi_status_t ret;
@@ -134,6 +136,41 @@ static int teardown(struct efi_unit_test *test, unsigned int *failures)
 }
 
 /*
+ * Check that a test exists.
+ *
+ * @testname:	name of the test
+ * @return:	test
+ */
+static struct efi_unit_test *find_test(const char *testname)
+{
+	struct efi_unit_test *test;
+
+	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
+	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		if (!efi_st_strcmp(testname, test->name))
+			return test;
+	}
+	efi_st_printf("\nTest '%s' not found\n", testname);
+	return NULL;
+}
+
+/*
+ * List all available tests.
+ */
+static void list_all_tests(void)
+{
+	struct efi_unit_test *test;
+
+	/* List all tests */
+	efi_st_printf("\nAvailable tests:\n");
+	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
+	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		efi_st_printf("'%s'%s\n", test->name,
+			      test->on_request ? " - on request" : "");
+	}
+}
+
+/*
  * Execute selftest of the EFI API
  *
  * This is the main entry point of the EFI selftest application.
@@ -155,6 +192,9 @@ efi_status_t EFIAPI efi_selftest(efi_handle_t image_handle,
 {
 	struct efi_unit_test *test;
 	unsigned int failures = 0;
+	const char *testname = NULL;
+	struct efi_loaded_image *loaded_image;
+	efi_status_t ret;
 
 	systable = systab;
 	boottime = systable->boottime;
@@ -163,14 +203,45 @@ efi_status_t EFIAPI efi_selftest(efi_handle_t image_handle,
 	con_out = systable->con_out;
 	con_in = systable->con_in;
 
+	ret = boottime->handle_protocol(image_handle, &efi_guid_loaded_image,
+					(void **)&loaded_image);
+	if (ret != EFI_SUCCESS) {
+		efi_st_error("Cannot open loaded image protocol");
+		return ret;
+	}
+	if (loaded_image->load_options)
+		testname = (char *)loaded_image->load_options;
+
+	if (testname) {
+		if (!efi_st_strcmp(testname, "list") || !find_test(testname)) {
+			list_all_tests();
+			/*
+			 * TODO:
+			 * Once the Exit boottime service is correctly
+			 * implemented we should call
+			 *   boottime->exit(image_handle, EFI_SUCCESS, 0, NULL);
+			 * here, cf.
+			 * https://lists.denx.de/pipermail/u-boot/2017-October/308720.html
+			 */
+			return EFI_SUCCESS;
+		}
+	}
+
 	efi_st_printf("\nTesting EFI API implementation\n");
 
-	efi_st_printf("\nNumber of tests to execute: %u\n",
-		      ll_entry_count(struct efi_unit_test, efi_unit_test));
+	if (testname)
+		printf("\nSelected test: %s\n", testname);
+	else
+		efi_st_printf("\nNumber of tests to execute: %u\n",
+			      ll_entry_count(struct efi_unit_test,
+					     efi_unit_test));
 
 	/* Execute boottime tests */
 	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
 	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		if (testname ?
+		    efi_st_strcmp(testname, test->name) : test->on_request)
+			continue;
 		if (test->phase == EFI_EXECUTE_BEFORE_BOOTTIME_EXIT) {
 			setup(test, &failures);
 			execute(test, &failures);
@@ -181,6 +252,9 @@ efi_status_t EFIAPI efi_selftest(efi_handle_t image_handle,
 	/* Execute mixed tests */
 	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
 	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		if (testname ?
+		    efi_st_strcmp(testname, test->name) : test->on_request)
+			continue;
 		if (test->phase == EFI_SETUP_BEFORE_BOOTTIME_EXIT)
 			setup(test, &failures);
 	}
@@ -189,6 +263,9 @@ efi_status_t EFIAPI efi_selftest(efi_handle_t image_handle,
 
 	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
 	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		if (testname ?
+		    efi_st_strcmp(testname, test->name) : test->on_request)
+			continue;
 		if (test->phase == EFI_SETUP_BEFORE_BOOTTIME_EXIT) {
 			execute(test, &failures);
 			teardown(test, &failures);
@@ -198,6 +275,9 @@ efi_status_t EFIAPI efi_selftest(efi_handle_t image_handle,
 	/* Execute runtime tests */
 	for (test = ll_entry_start(struct efi_unit_test, efi_unit_test);
 	     test < ll_entry_end(struct efi_unit_test, efi_unit_test); ++test) {
+		if (testname ?
+		    efi_st_strcmp(testname, test->name) : test->on_request)
+			continue;
 		if (test->phase == EFI_SETUP_AFTER_BOOTTIME_EXIT) {
 			setup(test, &failures);
 			execute(test, &failures);
diff --git a/lib/efi_selftest/efi_selftest_util.c b/lib/efi_selftest/efi_selftest_util.c
index 5cffe383d8..6d256e2e78 100644
--- a/lib/efi_selftest/efi_selftest_util.c
+++ b/lib/efi_selftest/efi_selftest_util.c
@@ -23,3 +23,12 @@ int efi_st_memcmp(const void *buf1, const void *buf2, size_t length)
 	}
 	return EFI_ST_SUCCESS;
 }
+
+int efi_st_strcmp(const char *buf1, const char *buf2)
+{
+	for (; *buf1 || *buf2; ++buf1, ++buf2) {
+		if (*buf1 != *buf2)
+			return *buf1 - *buf2;
+	}
+	return EFI_ST_SUCCESS;
+}
-- 
2.11.0

