From cda842ec153d7937e471b955a795561c652c5b02 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Wed, 20 Sep 2017 22:46:18 +0200
Subject: [PATCH 1/1] efi_loader: provide function comments for boot services

Provide comments describing the boot service functions.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 lib/efi_loader/efi_boottime.c | 566 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 565 insertions(+), 1 deletion(-)

diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 9e741c3cf3..e3c88d3df3 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -161,6 +161,19 @@ static u64 efi_div10(u64 a)
 	return ret;
 }
 
+/*
+ * Signal an EFI event
+ *
+ * This function queues the notification function of the event for future
+ * exectution.
+ *
+ * The notification function is called if the task priority level of the
+ * event is higher than the current task priority level.
+ *
+ * For the SignalEvent service see efi_signal_event_ext.
+ *
+ * @event	event to signal
+ */
 void efi_signal_event(struct efi_event *event)
 {
 	if (event->notify_function) {
@@ -174,12 +187,27 @@ void efi_signal_event(struct efi_event *event)
 	event->queued = 0;
 }
 
+/*
+ * Write a debug message for an EPI API service that is not implemented yet.
+ *
+ * @funcname	function that is not yes implemented
+ * @return	EFI_UNSUPPORTED
+ */
 static efi_status_t efi_unsupported(const char *funcname)
 {
 	debug("EFI: App called into unimplemented function %s\n", funcname);
 	return EFI_EXIT(EFI_UNSUPPORTED);
 }
 
+/*
+ * Raise the task priority level.
+ *
+ * This function implements the RaiseTpl service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @new_tpl	new value of the task priority level
+ * @return	old value of the task priority level
+ */
 static unsigned long EFIAPI efi_raise_tpl(UINTN new_tpl)
 {
 	UINTN old_tpl = efi_tpl;
@@ -196,6 +224,14 @@ static unsigned long EFIAPI efi_raise_tpl(UINTN new_tpl)
 	return old_tpl;
 }
 
+/*
+ * Lower the task priority level.
+ *
+ * This function implements the RestoreTpl service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @old_tpl	value of the task priority level to be restored
+ */
 static void EFIAPI efi_restore_tpl(UINTN old_tpl)
 {
 	EFI_ENTRY("0x%zx", old_tpl);
@@ -209,6 +245,18 @@ static void EFIAPI efi_restore_tpl(UINTN old_tpl)
 	EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Allocate memory pages.
+ *
+ * This function implements the AllocatePages service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @type		type of allocation to be performed
+ * @memory_type		unsage type of the allocated memory
+ * @pages number	of pages to be allocated
+ * @memory		allocated memory
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_allocate_pages_ext(int type, int memory_type,
 						  unsigned long pages,
 						  uint64_t *memory)
@@ -220,6 +268,16 @@ static efi_status_t EFIAPI efi_allocate_pages_ext(int type, int memory_type,
 	return EFI_EXIT(r);
 }
 
+/*
+ * Free memory pages.
+ *
+ * This function implements the FreePages service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @memory	start of the memory area to be freed
+ * @pages	number of pages to be freed
+ * @return	status code
+ */
 static efi_status_t EFIAPI efi_free_pages_ext(uint64_t memory,
 					      unsigned long pages)
 {
@@ -230,6 +288,20 @@ static efi_status_t EFIAPI efi_free_pages_ext(uint64_t memory,
 	return EFI_EXIT(r);
 }
 
+/*
+ * Get map describing memory usages.
+ *
+ * This function implements the GetMemoryMap service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @memory_map_size	on entry the size, in bytes, of the memory map buffer,
+ *			on exit the size of the copied memory map
+ * @memory_map		buffer to which the memory map is written
+ * @map_key		key for the memory map
+ * @descriptor_size	size of an individual memory descriptor
+ * @descriptor_version	version number of the memory descriptor structure
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_get_memory_map_ext(
 					unsigned long *memory_map_size,
 					struct efi_mem_desc *memory_map,
@@ -246,6 +318,17 @@ static efi_status_t EFIAPI efi_get_memory_map_ext(
 	return EFI_EXIT(r);
 }
 
+/*
+ * Allocate memory from pool.
+ *
+ * This function implements the AllocatePool service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @pool_type	type of the pool from which memory is to be allocated
+ * @size	number of bytes to be allocated
+ * @buffer	allocated memory
+ * @return	status code
+ */
 static efi_status_t EFIAPI efi_allocate_pool_ext(int pool_type,
 						 unsigned long size,
 						 void **buffer)
@@ -257,6 +340,15 @@ static efi_status_t EFIAPI efi_allocate_pool_ext(int pool_type,
 	return EFI_EXIT(r);
 }
 
+/*
+ * Free memory from pool.
+ *
+ * This function implements the FreePool service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @buffer	start of memory to be freed
+ * @return	status code
+ */
 static efi_status_t EFIAPI efi_free_pool_ext(void *buffer)
 {
 	efi_status_t r;
@@ -272,6 +364,20 @@ static efi_status_t EFIAPI efi_free_pool_ext(void *buffer)
  */
 static struct efi_event efi_events[16];
 
+/*
+ * Create an event.
+ *
+ * This function is used inside U-Boot code to create an event.
+ *
+ * For API function implementing the CreateEvent service see
+ * efi_create_event_ext.
+ *
+ * @type		type of the event to create
+ * @notify_tpl		task priority level of the event
+ * @notify_function	notification function of the event
+ * @event		created event
+ * @return		status code
+ */
 efi_status_t efi_create_event(uint32_t type, UINTN notify_tpl,
 			      void (EFIAPI *notify_function) (
 					struct efi_event *event,
@@ -307,6 +413,18 @@ efi_status_t efi_create_event(uint32_t type, UINTN notify_tpl,
 	return EFI_OUT_OF_RESOURCES;
 }
 
+/*
+ * Create an event.
+ *
+ * This function implements the CreateEvent service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @type		type of the event to create
+ * @notify_tpl		task priority level of the event
+ * @notify_function	notification function of the event
+ * @event		created event
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_create_event_ext(
 			uint32_t type, UINTN notify_tpl,
 			void (EFIAPI *notify_function) (
@@ -322,8 +440,11 @@ static efi_status_t EFIAPI efi_create_event_ext(
 
 
 /*
+ * Check if a timer event has occured or a queued notification function should
+ * be called.
+ *
  * Our timers have to work without interrupts, so we check whenever keyboard
- * input or disk accesses happen if enough time elapsed for it to fire.
+ * input or disk accesses happen if enough time elapsed for them to fire.
  */
 void efi_timer_check(void)
 {
@@ -355,6 +476,18 @@ void efi_timer_check(void)
 	WATCHDOG_RESET();
 }
 
+/*
+ * Set the trigger time for a timer event or stop the event.
+ *
+ * This is the function for internal usage in U-Boot. For the API function
+ * implementing the SetTimer service see efi_set_timer_ext.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @event		event for which the timer is set
+ * @type		type of the timer
+ * @trigger_time	trigger period in multiples of 100ns
+ * @return		status code
+ */
 efi_status_t efi_set_timer(struct efi_event *event, enum efi_timer_delay type,
 			   uint64_t trigger_time)
 {
@@ -392,6 +525,17 @@ efi_status_t efi_set_timer(struct efi_event *event, enum efi_timer_delay type,
 	return EFI_INVALID_PARAMETER;
 }
 
+/*
+ * Set the trigger time for a timer event or stop the event.
+ *
+ * This function implements the SetTimer service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @event		event for which the timer is set
+ * @type		type of the timer
+ * @trigger_time	trigger period in multiples of 100ns
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_set_timer_ext(struct efi_event *event,
 					     enum efi_timer_delay type,
 					     uint64_t trigger_time)
@@ -449,6 +593,17 @@ out:
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Signal an EFI event
+ *
+ * This function implements the SignalEvent service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * This functions sets the signaled state of the event an queues the
+ * notification function for exectution.
+ *
+ * @event	event to signal
+ */
 static efi_status_t EFIAPI efi_signal_event_ext(struct efi_event *event)
 {
 	int i;
@@ -467,6 +622,15 @@ static efi_status_t EFIAPI efi_signal_event_ext(struct efi_event *event)
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Close an EFI event
+ *
+ * This function implements the CloseEvent service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @event	event to close
+ * @return	status code
+ */
 static efi_status_t EFIAPI efi_close_event(struct efi_event *event)
 {
 	int i;
@@ -484,6 +648,17 @@ static efi_status_t EFIAPI efi_close_event(struct efi_event *event)
 	return EFI_EXIT(EFI_INVALID_PARAMETER);
 }
 
+/*
+ * Check if an event is signaled.
+ *
+ * This function implements the CheckEvent service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * If an event is not signaled yet the notification function is queued.
+ *
+ * @event	event to check
+ * @return	status code
+ */
 static efi_status_t EFIAPI efi_check_event(struct efi_event *event)
 {
 	int i;
@@ -504,6 +679,18 @@ static efi_status_t EFIAPI efi_check_event(struct efi_event *event)
 	return EFI_EXIT(EFI_INVALID_PARAMETER);
 }
 
+/*
+ * Install protocol interface
+ *
+ * For the implementation of the InstallProtocolInterface service see function
+ * efi_install_protocol_interface_ext.
+ *
+ * @handle			handle on which the protocol shall be installed
+ * @protocol			GUID of the protocol to be installed
+ * @protocol_interface_type	type of the interface to be installed
+ * @protocol_interface		interface of the protocol implementation
+ * @return			status code
+ */
 static efi_status_t EFIAPI efi_install_protocol_interface(void **handle,
 			efi_guid_t *protocol, int protocol_interface_type,
 			void *protocol_interface)
@@ -561,6 +748,18 @@ out:
 	return r;
 }
 
+/*
+ * Install protocol interface
+ *
+ * This function implements the InstallProtocolInterface service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle			handle on which the protocol shall be installed
+ * @protocol			GUID of the protocol to be installed
+ * @protocol_interface_type	type of the interface to be installed
+ * @protocol_interface		interface of the protocol implementation
+ * @return			status code
+ */
 static efi_status_t EFIAPI efi_install_protocol_interface_ext(void **handle,
 			efi_guid_t *protocol, int protocol_interface_type,
 			void *protocol_interface)
@@ -573,6 +772,19 @@ static efi_status_t EFIAPI efi_install_protocol_interface_ext(void **handle,
 						       protocol_interface));
 }
 
+/*
+ * Reinstall protocol interface
+ *
+ * This function implements the ReinstallProtocolInterface service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle			handle on which the protocol shall be
+ 				reinstalled
+ * @protocol			GUID of the protocol to be installed
+ * @old_interface		interface to be removed
+ * @new_interface		interface to be installed
+ * @return			status code
+ */
 static efi_status_t EFIAPI efi_reinstall_protocol_interface(void *handle,
 			efi_guid_t *protocol, void *old_interface,
 			void *new_interface)
@@ -582,6 +794,17 @@ static efi_status_t EFIAPI efi_reinstall_protocol_interface(void *handle,
 	return EFI_EXIT(EFI_ACCESS_DENIED);
 }
 
+/*
+ * Uninstall protocol interface
+ *
+ * For the implementation of the UninstallProtocolInterface service see function
+ * efi_uninstall_protocol_interface_ext.
+ *
+ * @handle			handle from which the protocol shall be removed
+ * @protocol			GUID of the protocol to be removed
+ * @protocol_interface		interface to be removed
+ * @return			status code
+ */
 static efi_status_t EFIAPI efi_uninstall_protocol_interface(void *handle,
 			efi_guid_t *protocol, void *protocol_interface)
 {
@@ -623,6 +846,17 @@ out:
 	return r;
 }
 
+/*
+ * Uninstall protocol interface
+ *
+ * This function implements the UninstallProtocolInterface service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle			handle from which the protocol shall be removed
+ * @protocol			GUID of the protocol to be removed
+ * @protocol_interface		interface to be removed
+ * @return			status code
+ */
 static efi_status_t EFIAPI efi_uninstall_protocol_interface_ext(void *handle,
 			efi_guid_t *protocol, void *protocol_interface)
 {
@@ -632,6 +866,18 @@ static efi_status_t EFIAPI efi_uninstall_protocol_interface_ext(void *handle,
 							 protocol_interface));
 }
 
+/*
+ * Register an event for notification when a protocol is registered.
+ *
+ * This function implements the RegisterProtocolNotify service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @protocol		GUID of the protocol whose registration shall be
+ *			notified
+ * @event		event to be signaled upon registration of the protocol
+ * @registration	key for retrieving the registration information
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_register_protocol_notify(efi_guid_t *protocol,
 							struct efi_event *event,
 							void **registration)
@@ -640,6 +886,17 @@ static efi_status_t EFIAPI efi_register_protocol_notify(efi_guid_t *protocol,
 	return EFI_EXIT(EFI_OUT_OF_RESOURCES);
 }
 
+/*
+ * Determine if an EFI handle implements a protocol.
+ *
+ * See the documentation of the LocateHandle service in the UEFI specification.
+ *
+ * @search_type		selection criterion
+ * @protocol		GUID of the protocol
+ * @search_key		registration key
+ * @efi_obj		handle
+ * @return		0 if the handle implements the protocol
+ */
 static int efi_search(enum efi_locate_search_type search_type,
 		      efi_guid_t *protocol, void *search_key,
 		      struct efi_object *efiobj)
@@ -663,6 +920,19 @@ static int efi_search(enum efi_locate_search_type search_type,
 	return -1;
 }
 
+/*
+ * Locate handles implementing a protocol.
+ *
+ * This function is meant for U-Boot internal calls. For the implemenation of
+ * the LocateHandle service see efi_locate_handle_ext.
+ *
+ * @search_type		selection criterion
+ * @protocol		GUID of the protocol
+ * @search_key		registration key
+ * @buffer_size		size of the buffer to receive the handles in bytes
+ * @buffer		buffer to receive the relevant handles
+ * @return		0 if the handle implements the protocol
+ */
 static efi_status_t efi_locate_handle(
 			enum efi_locate_search_type search_type,
 			efi_guid_t *protocol, void *search_key,
@@ -701,6 +971,19 @@ static efi_status_t efi_locate_handle(
 	return EFI_SUCCESS;
 }
 
+/*
+ * Locate handles implementing a protocol.
+ *
+ * This function implments the LocateHandle service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @search_type		selection criterion
+ * @protocol		GUID of the protocol
+ * @search_key		registration key
+ * @buffer_size		size of the buffer to receive the handles in bytes
+ * @buffer		buffer to receive the relevant handles
+ * @return		0 if the handle implements the protocol
+ */
 static efi_status_t EFIAPI efi_locate_handle_ext(
 			enum efi_locate_search_type search_type,
 			efi_guid_t *protocol, void *search_key,
@@ -713,6 +996,17 @@ static efi_status_t EFIAPI efi_locate_handle_ext(
 			buffer_size, buffer));
 }
 
+/*
+ * Get the device path and handle of an device implementing a protocol.
+ *
+ * This function implements the LocateDevicePath service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @protocol		GUID of the protocol
+ * @device_path		device path
+ * @device		handle of the device
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_locate_device_path(efi_guid_t *protocol,
 			struct efi_device_path **device_path,
 			efi_handle_t *device)
@@ -741,6 +1035,16 @@ static void efi_remove_configuration_table(int i)
 	systab.nr_tables--;
 }
 
+/*
+ * Adds, updates, or removes a configuration table.
+ *
+ * This function is used for internal calls. For the implemenation of the
+ * InstallConfigurationTable service see efi_install_configuration_table_ext.
+ *
+ * @guid		GUID of the installed table
+ * @table		table to be installed
+ * @return		status code
+ */
 efi_status_t efi_install_configuration_table(const efi_guid_t *guid, void *table)
 {
 	int i;
@@ -771,6 +1075,16 @@ efi_status_t efi_install_configuration_table(const efi_guid_t *guid, void *table
 	return EFI_SUCCESS;
 }
 
+/*
+ * Adds, updates, or removes a configuration table.
+ *
+ * This function implements the InstallConfigurationTable service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @guid		GUID of the installed table
+ * @table		table to be installed
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_install_configuration_table_ext(efi_guid_t *guid,
 							       void *table)
 {
@@ -855,6 +1169,20 @@ error:
 	return ret;
 }
 
+/*
+ * Load an EFI image into memory.
+ *
+ * This function implements the LoadImage service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @boot_policy		true for request originating from the boot manager
+ * @parent_image	the calles's image handle
+ * @file_path		the path of the image to load
+ * @source_buffer	memory location from which the image is installed
+ * @source_size		size of the memory area from which the image is installed
+ * @image_handle	handle for the newly installed image
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_load_image(bool boot_policy,
 					  efi_handle_t parent_image,
 					  struct efi_device_path *file_path,
@@ -908,6 +1236,16 @@ static efi_status_t EFIAPI efi_load_image(bool boot_policy,
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Call the entry point of an image.
+ *
+ * This function implements the StartImage service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ * 
+ * @image_handle	handle of the image
+ * @exit_data_size	size of the buffer
+ * @exit_data		buffer to receive the exit data of the called image
+ */
 static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
 					   unsigned long *exit_data_size,
 					   s16 **exit_data)
@@ -936,6 +1274,17 @@ static efi_status_t EFIAPI efi_start_image(efi_handle_t image_handle,
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Leave an EFI application.
+ *
+ * This function implements the Exit service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @image_handle	handle of the application of driver that is exiting
+ * @exit_status		status code
+ * @exit_data_size	size of the buffer in bytes
+ * @exit_data		buffer with data describing an error
+ */
 static efi_status_t EFIAPI efi_exit(efi_handle_t image_handle,
 			efi_status_t exit_status, unsigned long exit_data_size,
 			int16_t *exit_data)
@@ -960,6 +1309,12 @@ static efi_status_t EFIAPI efi_exit(efi_handle_t image_handle,
 	panic("EFI application exited");
 }
 
+/*
+ * Find the internal EFI object for a handle.
+ *
+ * @handle	handle to find
+ * @return	EFI object
+ */
 static struct efi_object *efi_search_obj(void *handle)
 {
 	struct list_head *lhandle;
@@ -974,6 +1329,15 @@ static struct efi_object *efi_search_obj(void *handle)
 	return NULL;
 }
 
+/*
+ * Unload an EFI image.
+ *
+ * This function implements the UnloadImage service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @image_handle	handle of the image to be unloaded
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_unload_image(void *image_handle)
 {
 	struct efi_object *efiobj;
@@ -986,6 +1350,9 @@ static efi_status_t EFIAPI efi_unload_image(void *image_handle)
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Fix up caches for EFI payloads if necessary.
+ */
 static void efi_exit_caches(void)
 {
 #if defined(CONFIG_ARM) && !defined(CONFIG_ARM64)
@@ -998,6 +1365,16 @@ static void efi_exit_caches(void)
 #endif
 }
 
+/*
+ * Stop boot services.
+ *
+ * This function implements the ExitBootServices service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @image_handle	handle of the loaded image
+ * @map_key		key of the memory map
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_exit_boot_services(void *image_handle,
 						  unsigned long map_key)
 {
@@ -1033,6 +1410,15 @@ static efi_status_t EFIAPI efi_exit_boot_services(void *image_handle,
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Get next value of the counter.
+ *
+ * This function implements the NextMonotonicCount service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @count	returned value of the counter
+ * @return	status code
+ */
 static efi_status_t EFIAPI efi_get_next_monotonic_count(uint64_t *count)
 {
 	static uint64_t mono = 0;
@@ -1041,6 +1427,15 @@ static efi_status_t EFIAPI efi_get_next_monotonic_count(uint64_t *count)
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Sleep.
+ *
+ * This function implements the Stall sercive.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @microseconds	period to sleep in microseconds
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_stall(unsigned long microseconds)
 {
 	EFI_ENTRY("%ld", microseconds);
@@ -1048,6 +1443,17 @@ static efi_status_t EFIAPI efi_stall(unsigned long microseconds)
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Reset the watchdog timer.
+ *
+ * This function implements the WatchdogTimer service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @timeout		seconds before reset by watchdog
+ * @watchdog_code	code to be logged when resetting
+ * @data_size		size of buffer in bytes
+ * @watchdog_data	buffer with data describing the reset reason
+ */
 static efi_status_t EFIAPI efi_set_watchdog_timer(unsigned long timeout,
 						  uint64_t watchdog_code,
 						  unsigned long data_size,
@@ -1058,6 +1464,17 @@ static efi_status_t EFIAPI efi_set_watchdog_timer(unsigned long timeout,
 	return efi_unsupported(__func__);
 }
 
+/*
+ * Connect controller to a driver.
+ *
+ * This function implements the ConnectController service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @controller_handle	handle of the controller
+ * @driver_image_handle	handle of the driver
+ * @remain_device_path	device path of a child controller
+ * @recursive		true to connect all child controllers
+ */
 static efi_status_t EFIAPI efi_connect_controller(
 			efi_handle_t controller_handle,
 			efi_handle_t *driver_image_handle,
@@ -1069,6 +1486,17 @@ static efi_status_t EFIAPI efi_connect_controller(
 	return EFI_EXIT(EFI_NOT_FOUND);
 }
 
+/*
+ * Disconnect controller to a driver.
+ *
+ * This function implements the DisconnectController service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @controller_handle	handle of the controller
+ * @driver_image_handle handle of the driver
+ * @child_handle	handle of the child to destroy
+ * @recursive		true to connect all child controllers
+ */
 static efi_status_t EFIAPI efi_disconnect_controller(void *controller_handle,
 						     void *driver_image_handle,
 						     void *child_handle)
@@ -1078,6 +1506,18 @@ static efi_status_t EFIAPI efi_disconnect_controller(void *controller_handle,
 	return EFI_EXIT(EFI_INVALID_PARAMETER);
 }
 
+/*
+ * Close a protocol.
+ *
+ * This function implements the CloseProtocol service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle		handle on which the protocol shall be closed
+ * @protocol		GUID of the protocol to close
+ * @agent_handle	handle of the driver
+ * @controller_handle	handle of the controller
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_close_protocol(void *handle,
 					      efi_guid_t *protocol,
 					      void *agent_handle,
@@ -1088,6 +1528,18 @@ static efi_status_t EFIAPI efi_close_protocol(void *handle,
 	return EFI_EXIT(EFI_NOT_FOUND);
 }
 
+/*
+ * Provide information about then open status of a protocol on a handle
+ *
+ * This function implements the OpenProtocolInformation service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle		handle for which the information shall be retrieved
+ * @protocol		GUID of the protocol
+ * @entry_buffer	buffer to receive the open protocol information
+ * @entry_count		number of entries available in the buffer
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_open_protocol_information(efi_handle_t handle,
 			efi_guid_t *protocol,
 			struct efi_open_protocol_info_entry **entry_buffer,
@@ -1098,6 +1550,17 @@ static efi_status_t EFIAPI efi_open_protocol_information(efi_handle_t handle,
 	return EFI_EXIT(EFI_NOT_FOUND);
 }
 
+
+/*
+ * Get protocols installed on a handle.
+ *
+ * This function implements the ProtocolsPerHandleService.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle			handle for which the information is retrieved
+ * @protocol_buffer		buffer with protocol GUIDs
+ * @protocol_buffer_count	number of entries in the buffer
+ */
 static efi_status_t EFIAPI efi_protocols_per_handle(void *handle,
 			efi_guid_t ***protocol_buffer,
 			unsigned long *protocol_buffer_count)
@@ -1151,6 +1614,19 @@ static efi_status_t EFIAPI efi_protocols_per_handle(void *handle,
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Locate handles implementing a protocol.
+ *
+ * This function implemnts the LocateHandleBuffer service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @search_type		selection criterion
+ * @protocol		GUID of the protocol
+ * @search_key		registration key
+ * @no_handles		number of handles returned
+ * @buffer		buffer to with the relevant handles
+ * @return		0 if the handle implements the protocol
+ */
 static efi_status_t EFIAPI efi_locate_handle_buffer(
 			enum efi_locate_search_type search_type,
 			efi_guid_t *protocol, void *search_key,
@@ -1184,6 +1660,16 @@ out:
 	return EFI_EXIT(r);
 }
 
+/*
+ * Find an interface implementing a protocol.
+ *
+ * This function implemements the LocateProtocol service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @protocol		GUID of the protocol
+ * @registration	registration key passed to the notification function
+ * @protocol_interface	interface implementing the protocol
+ */
 static efi_status_t EFIAPI efi_locate_protocol(efi_guid_t *protocol,
 					       void *registration,
 					       void **protocol_interface)
@@ -1219,6 +1705,17 @@ static efi_status_t EFIAPI efi_locate_protocol(efi_guid_t *protocol,
 	return EFI_EXIT(EFI_NOT_FOUND);
 }
 
+/*
+ * Install multiple protocol interfaces.
+ *
+ * This function implements the MultipleProtocolInterfaces service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle	handle on which the protocol interfaces shall be installed
+ * @...		NULL terminated argument list with pairs of protocol GUIDS and
+ *		interfaces
+ * @return	status code
+ */
 static efi_status_t EFIAPI efi_install_multiple_protocol_interfaces(
 			void **handle, ...)
 {
@@ -1263,6 +1760,17 @@ static efi_status_t EFIAPI efi_install_multiple_protocol_interfaces(
 	return EFI_EXIT(r);
 }
 
+/*
+ * Uninstall multiple protocol interfaces.
+ *
+ * This function implements the UninstallMultipleProtocolInterfaces service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle	handle from which the protocol interfaces shall be removed
+ * @...		NULL terminated argument list with pairs of protocol GUIDS and
+ *		interfaces
+ * @return	status code
+ */
 static efi_status_t EFIAPI efi_uninstall_multiple_protocol_interfaces(
 			void *handle, ...)
 {
@@ -1270,6 +1778,17 @@ static efi_status_t EFIAPI efi_uninstall_multiple_protocol_interfaces(
 	return EFI_EXIT(EFI_INVALID_PARAMETER);
 }
 
+/*
+ * Calculate cyclic redundancy code.
+ *
+ * This function implements the CalculateCrc32 service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @data	buffer with data
+ * @data_size	size of buffer in bytes
+ * @crc32_p	cyclic redundancy code
+ * @return	status code
+ */
 static efi_status_t EFIAPI efi_calculate_crc32(void *data,
 					       unsigned long data_size,
 					       uint32_t *crc32_p)
@@ -1279,6 +1798,16 @@ static efi_status_t EFIAPI efi_calculate_crc32(void *data,
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
+/*
+ * Copy memory.
+ *
+ * This function implements the CopyMem service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @destination		destination of the copy operation
+ * @source		source of the copy operation
+ * @length		number of bytes to copy
+ */
 static void EFIAPI efi_copy_mem(void *destination, void *source,
 				unsigned long length)
 {
@@ -1286,12 +1815,36 @@ static void EFIAPI efi_copy_mem(void *destination, void *source,
 	memcpy(destination, source, length);
 }
 
+/*
+ * Fill memory with a byte value.
+ *
+ * This function implements the SetMem service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @buffer		buffer to fill
+ * @size		size of buffer in bytes
+ * @value		byte to copy to the buffer
+ */
 static void EFIAPI efi_set_mem(void *buffer, unsigned long size, uint8_t value)
 {
 	EFI_ENTRY("%p, %ld, 0x%x", buffer, size, value);
 	memset(buffer, value, size);
 }
 
+/*
+ * Open protocol interface on a handle.
+ *
+ * This function implements the OpenProtocol interface.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle		handle on which the protocol shall be opened
+ * @protocol		GUID of the protocol
+ * @protocol_interface	interface implementing the protcol
+ * @agent_handle	handle of the driver
+ * @controller_handle	handle of the controller
+ * @attributes		attributes of the protocol opening
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_open_protocol(
 			void *handle, efi_guid_t *protocol,
 			void **protocol_interface, void *agent_handle,
@@ -1364,6 +1917,17 @@ out:
 	return EFI_EXIT(r);
 }
 
+/*
+ * Get interface of a protocol on a handle.
+ *
+ * This function implements the HandleProtocol service.
+ * See Unified Extensible Firmware Interface (UEFI) specification for details.
+ *
+ * @handle		handle on which the protocol shall be opened
+ * @protocol		GUID of the protocol
+ * @protocol_interface  interface implementing the protocol
+ * @return		status code
+ */
 static efi_status_t EFIAPI efi_handle_protocol(void *handle,
 					       efi_guid_t *protocol,
 					       void **protocol_interface)
-- 
2.11.0

