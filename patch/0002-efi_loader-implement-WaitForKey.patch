From 67418a610c64bc5953e00ec0627441c121e0906b Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 2 Jul 2017 19:11:30 +0200
Subject: [PATCH 1/1] efi_loader: implement WaitForKey

The EFI_SIMPLE_TEXT_INPUT_PROTOCOL requires an event WaitForKey.

We can easily signal the event in the efi_timer_check function.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h          |  5 ++++-
 lib/efi_loader/efi_boottime.c | 17 ++++++++++++++---
 lib/efi_loader/efi_console.c  |  2 +-
 3 files changed, 19 insertions(+), 5 deletions(-)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index 7b7667d5c8..e12cdf389d 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -85,7 +85,10 @@ struct efi_event {
 	enum efi_event_type trigger_type;
 	int signaled;
 };
-
+extern struct efi_event efi_events[];
+#define WAIT_FOR_KEY_EVENT (&efi_events[0])
+/* Events below this number cannot be closed */
+#define FIRST_EDITABLE_EVENT 1
 
 /* This list contains all UEFI objects we know of */
 extern struct list_head efi_obj_list;
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index e3d978845f..7244670445 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -178,7 +178,13 @@ static efi_status_t EFIAPI efi_free_pool_ext(void *buffer)
  * Our event capabilities are very limited. Only a small limited
  * number of events is allowed to coexist.
  */
-static struct efi_event efi_events[16];
+struct efi_event efi_events[16] = {
+	{
+		/* WaitForKey */
+		.type = EVT_NOTIFY_WAIT,
+		.trigger_next = -1ULL,
+	}
+};
 
 efi_status_t efi_create_event(enum efi_event_type type, UINTN notify_tpl,
 			      void (EFIAPI *notify_function) (
@@ -198,7 +204,8 @@ efi_status_t efi_create_event(enum efi_event_type type, UINTN notify_tpl,
 	    notify_function == NULL)
 		return EFI_INVALID_PARAMETER;
 
-	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
+	/* Use first empty slot */
+	for (i = FIRST_EDITABLE_EVENT; i < ARRAY_SIZE(efi_events); ++i) {
 		if (efi_events[i].type)
 			continue;
 		efi_events[i].type = type;
@@ -237,6 +244,10 @@ void efi_timer_check(void)
 	int i;
 	u64 now = timer_get_us();
 
+	/* Signal keystroke */
+	if (tstc())
+		efi_events[0].signaled = 1;
+
 	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
 		if (!efi_events[i].type ||
 		    !(efi_events[i].type & EVT_TIMER) ||
@@ -357,7 +368,7 @@ static efi_status_t EFIAPI efi_close_event(struct efi_event *event)
 	int i;
 
 	EFI_ENTRY("%p", event);
-	for (i = 0; i < ARRAY_SIZE(efi_events); ++i) {
+	for (i = FIRST_EDITABLE_EVENT; i < ARRAY_SIZE(efi_events); ++i) {
 		if (event == &efi_events[i]) {
 			event->type = 0;
 			event->trigger_next = -1ULL;
diff --git a/lib/efi_loader/efi_console.c b/lib/efi_loader/efi_console.c
index 81acabbd7c..968855d6be 100644
--- a/lib/efi_loader/efi_console.c
+++ b/lib/efi_loader/efi_console.c
@@ -424,7 +424,7 @@ static efi_status_t EFIAPI efi_cin_read_key_stroke(
 const struct efi_simple_input_interface efi_con_in = {
 	.reset = efi_cin_reset,
 	.read_key_stroke = efi_cin_read_key_stroke,
-	.wait_for_key = NULL,
+	.wait_for_key = WAIT_FOR_KEY_EVENT,
 };
 
 static struct efi_event *console_timer_event;
-- 
2.13.2

