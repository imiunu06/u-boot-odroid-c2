From f75b2bd73d99b9b598f5616c08b43c2f265beab6 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Tue, 26 Dec 2017 00:46:56 +0100
Subject: [PATCH v4 1/1] vsprintf.c: add EFI device path printing

For debugging efi_loader we need the capability to print EFI
device paths. With this patch we can write:

    debug("device path: %pD", dp);

A possible output would be

    device path: /MemoryMapped(0x0,0x3ff93a82,0x3ff93a82)

This enhancement is not available when building without EFI support
and neither in the SPL nor in the API example.

A test is provided. It can be executed in the sandbox with command
ut_print.

The development for EFI support in the sandbox is currently in
branch u-boot-dm/efi-working. The branch currently lacks
commit 6ea8b580f06b ("efi_loader: correct DeviceNodeToText
for media types"). Ater rebasing the aforementioned branch on
U-Boot v2018.01 the test is executed successfully.

Without EFI support in the sandbox the test is simply skipped.

Cc: Wolfgang Denk <wd@denx.de>
Cc: Simon Glass <sjg@chromium.org>
Suggested-by: Rob Clark <robdclark@gmail.com>
Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
I propose Alex picks up this patch for the EFI tree.

v4:
	Add unit test.
v3:
	Return -ENOMEM if out of memory.
	Avoid missing dependency error when building the SPL of the
	API example.
v2:
	Panic if out of memory.
	Wolfgang suggested not to silently ignore an out of memory
	situation.
---
 examples/api/Makefile |  3 +++
 lib/vsprintf.c        | 47 +++++++++++++++++++++++++++++++++++++++++------
 test/print_ut.c       | 37 +++++++++++++++++++++++++++++++++++++
 3 files changed, 81 insertions(+), 6 deletions(-)

diff --git a/examples/api/Makefile b/examples/api/Makefile
index 899527267d..9068727b98 100644
--- a/examples/api/Makefile
+++ b/examples/api/Makefile
@@ -4,6 +4,9 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+# Provide symbol API_BUILD to signal that the API example is being built.
+KBUILD_CPPFLAGS += -DAPI_BUILD
+
 ifeq ($(ARCH),powerpc)
 LOAD_ADDR = 0x40000
 endif
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index dd572d2868..226f4eb3e5 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -11,16 +11,17 @@
  * from hush: simple_itoa() was lifted from boa-0.93.15
  */
 
-#include <stdarg.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/ctype.h>
-
 #include <common.h>
 #include <charset.h>
+#include <efi_loader.h>
+#include <div64.h>
 #include <uuid.h>
+#include <stdarg.h>
+#include <linux/ctype.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include <linux/string.h>
 
-#include <div64.h>
 #define noinline __attribute__((noinline))
 
 /* we use this so that we can do without the ctype library */
@@ -292,6 +293,26 @@ static char *string16(char *buf, char *end, u16 *s, int field_width,
 	return buf;
 }
 
+#if defined(CONFIG_EFI_LOADER) && \
+	!defined(CONFIG_SPL_BUILD) && !defined(API_BUILD)
+static char *device_path_string(char *buf, char *end, void *dp, int field_width,
+				int precision, int flags)
+{
+	u16 *str;
+
+	if (!dp)
+		return "<NULL>";
+
+	str = efi_dp_str((struct efi_device_path *)dp);
+	if (!str)
+		return ERR_PTR(-ENOMEM);
+
+	buf = string16(buf, end, str, field_width, precision, flags);
+	efi_free_pool(str);
+	return buf;
+}
+#endif
+
 #ifdef CONFIG_CMD_NET
 static const char hex_asc[] = "0123456789abcdef";
 #define hex_asc_lo(x)	hex_asc[((x) & 0x0f)]
@@ -435,6 +456,12 @@ static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
 #endif
 
 	switch (*fmt) {
+#if defined(CONFIG_EFI_LOADER) && \
+	!defined(CONFIG_SPL_BUILD) && !defined(API_BUILD)
+	case 'D':
+		return device_path_string(buf, end, ptr, field_width,
+					  precision, flags);
+#endif
 #ifdef CONFIG_CMD_NET
 	case 'a':
 		flags |= SPECIAL | ZEROPAD;
@@ -604,6 +631,8 @@ repeat:
 			str = pointer(fmt + 1, str, end,
 					va_arg(args, void *),
 					field_width, precision, flags);
+			if (IS_ERR(str))
+				return PTR_ERR(str);
 			/* Skip all alphanumeric pointer suffixes */
 			while (isalnum(fmt[1]))
 				fmt++;
@@ -768,6 +797,9 @@ int printf(const char *fmt, ...)
 	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
 	va_end(args);
 
+	/* Handle error */
+	if (i <= 0)
+		return i;
 	/* Print the string */
 	puts(printbuffer);
 	return i;
@@ -784,6 +816,9 @@ int vprintf(const char *fmt, va_list args)
 	 */
 	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
 
+	/* Handle error */
+	if (i <= 0)
+		return i;
 	/* Print the string */
 	puts(printbuffer);
 	return i;
diff --git a/test/print_ut.c b/test/print_ut.c
index a42c554bef..d10ed8695b 100644
--- a/test/print_ut.c
+++ b/test/print_ut.c
@@ -7,12 +7,46 @@
 #define DEBUG
 
 #include <common.h>
+#if defined(CONFIG_EFI_LOADER) && \
+	!defined(CONFIG_SPL_BUILD) && !defined(API_BUILD)
+#include <efi_api.h>
+#endif
 #include <display_options.h>
 #include <version.h>
 
 #define FAKE_BUILD_TAG	"jenkins-u-boot-denx_uboot_dm-master-build-aarch64" \
 			"and a lot more text to come"
 
+/* Test efi_loader specific printing */
+static void efi_ut_print(void)
+{
+#if defined(CONFIG_EFI_LOADER) && \
+    !defined(CONFIG_SPL_BUILD) && !defined(API_BUILD)
+	char str[10];
+	u8 buf[sizeof(struct efi_device_path_sd_mmc_path) +
+	       sizeof(struct efi_device_path)];
+	u8 *pos = buf;
+	struct efi_device_path *dp_end;
+	struct efi_device_path_sd_mmc_path *dp_sd =
+			(struct efi_device_path_sd_mmc_path *)pos;
+
+	/* Create a device path for an SD card */
+	dp_sd->dp.type = DEVICE_PATH_TYPE_MESSAGING_DEVICE;
+	dp_sd->dp.sub_type = DEVICE_PATH_SUB_TYPE_MSG_SD;
+	dp_sd->dp.length = sizeof(struct efi_device_path_sd_mmc_path);
+	dp_sd->slot_number = 3;
+	pos += sizeof(struct efi_device_path_sd_mmc_path);
+	/* Append end node */
+	dp_end = (struct efi_device_path *)pos;
+	dp_end->type = DEVICE_PATH_TYPE_END;
+	dp_end->sub_type = DEVICE_PATH_SUB_TYPE_END;
+	dp_end->length = sizeof(struct efi_device_path);
+
+	snprintf(str, sizeof(str), "_%pD_", buf);
+	assert(!strcmp("_/SD(3)_", str));
+#endif
+}
+
 static int do_ut_print(cmd_tbl_t *cmdtp, int flag, int argc,
 		       char *const argv[])
 {
@@ -75,6 +109,9 @@ static int do_ut_print(cmd_tbl_t *cmdtp, int flag, int argc,
 	assert(!strncmp(FAKE_BUILD_TAG, s + 9 + len, 12));
 	assert(!strcmp("\n\n", s + big_str_len - 3));
 
+	/* Test efi_loader specific printing */
+	efi_ut_print();
+
 	printf("%s: Everything went swimmingly\n", __func__);
 	return 0;
 }
-- 
2.11.0

