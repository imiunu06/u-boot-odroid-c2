From f81f320eca448ede2b23b02cdaf3dc282288bad8 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 21 Jan 2018 20:49:53 +0100
Subject: [PATCH 1/1] efi_selftest: check installation of the device tree

The unit test checks if a device tree is installed. It requires that the
compatible property of the root node exists. If available it prints the
serial-number property.

The serial-number property is derived from the environment variable
'serial#'. This can be used to check if the image_setup_libfdt() function
is executed.

With this patch the same routine is used to install the device tree both
for loading an external image and for running bootefi selftest.

A Python test is supplied. It sets a value for serial# and checks that the
selftest shows this as serial-number.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 cmd/bootefi.c                       |  69 ++++++++------
 lib/efi_selftest/Makefile           |   1 +
 lib/efi_selftest/efi_selftest_fdt.c | 182 ++++++++++++++++++++++++++++++++++++
 test/py/tests/test_efi_selftest.py  |  13 +++
 4 files changed, 237 insertions(+), 28 deletions(-)
 create mode 100644 lib/efi_selftest/efi_selftest_fdt.c

diff --git a/cmd/bootefi.c b/cmd/bootefi.c
index 2c4aa06c42..e589590ce3 100644
--- a/cmd/bootefi.c
+++ b/cmd/bootefi.c
@@ -149,6 +149,40 @@ static efi_status_t efi_run_in_el2(asmlinkage ulong (*entry)(
 }
 #endif
 
+static efi_status_t efi_install_fdt(void *fdt)
+{
+	bootm_headers_t img = { 0 };
+	ulong fdt_pages, fdt_size, fdt_start, fdt_end;
+	const efi_guid_t fdt_guid = EFI_FDT_GUID;
+
+	if (fdt && !fdt_check_header(fdt)) {
+		/* Prepare fdt for payload */
+		fdt = copy_fdt(fdt);
+
+		if (image_setup_libfdt(&img, fdt, 0, NULL)) {
+			printf("ERROR: Failed to process device tree\n");
+			return EFI_LOAD_ERROR;
+		}
+
+		/* Link to it in the efi tables */
+		efi_install_configuration_table(&fdt_guid, fdt);
+
+		/* And reserve the space in the memory map */
+		fdt_start = ((ulong)fdt) & ~EFI_PAGE_MASK;
+		fdt_end = ((ulong)fdt) + fdt_totalsize(fdt);
+		fdt_size = (fdt_end - fdt_start) + EFI_PAGE_MASK;
+		fdt_pages = fdt_size >> EFI_PAGE_SHIFT;
+		/* Give a bootloader the chance to modify the device tree */
+		fdt_pages += 2;
+		efi_add_memory_map(fdt_start, fdt_pages,
+				   EFI_BOOT_SERVICES_DATA, true);
+	} else {
+		printf("WARNING: Invalid device tree, expect boot to fail\n");
+		efi_install_configuration_table(&fdt_guid, NULL);
+	}
+	return 0;
+}
+
 /*
  * Load an EFI payload into a newly allocated piece of memory, register all
  * EFI objects it would want to access and jump to it.
@@ -164,9 +198,6 @@ static efi_status_t do_bootefi_exec(void *efi, void *fdt,
 
 	ulong (*entry)(efi_handle_t image_handle, struct efi_system_table *st)
 		asmlinkage;
-	ulong fdt_pages, fdt_size, fdt_start, fdt_end;
-	const efi_guid_t fdt_guid = EFI_FDT_GUID;
-	bootm_headers_t img = { 0 };
 
 	/*
 	 * Special case for efi payload not loaded from disk, such as
@@ -195,31 +226,9 @@ static efi_status_t do_bootefi_exec(void *efi, void *fdt,
 	 */
 	efi_save_gd();
 
-	if (fdt && !fdt_check_header(fdt)) {
-		/* Prepare fdt for payload */
-		fdt = copy_fdt(fdt);
-
-		if (image_setup_libfdt(&img, fdt, 0, NULL)) {
-			printf("ERROR: Failed to process device tree\n");
-			return -EINVAL;
-		}
-
-		/* Link to it in the efi tables */
-		efi_install_configuration_table(&fdt_guid, fdt);
-
-		/* And reserve the space in the memory map */
-		fdt_start = ((ulong)fdt) & ~EFI_PAGE_MASK;
-		fdt_end = ((ulong)fdt) + fdt_totalsize(fdt);
-		fdt_size = (fdt_end - fdt_start) + EFI_PAGE_MASK;
-		fdt_pages = fdt_size >> EFI_PAGE_SHIFT;
-		/* Give a bootloader the chance to modify the device tree */
-		fdt_pages += 2;
-		efi_add_memory_map(fdt_start, fdt_pages,
-				   EFI_BOOT_SERVICES_DATA, true);
-	} else {
-		printf("WARNING: Invalid device tree, expect boot to fail\n");
-		efi_install_configuration_table(&fdt_guid, NULL);
-	}
+	ret = efi_install_fdt(fdt);
+	if (ret)
+		goto exit;
 
 	/* Transfer environment variable bootargs as load options */
 	set_load_options(&loaded_image_info, "bootargs");
@@ -377,6 +386,10 @@ static int do_bootefi(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			efi_init_obj_list();
 		/* Transfer environment variable efi_selftest as load options */
 		set_load_options(&loaded_image_info, "efi_selftest");
+		/* Install device tree */
+		r = efi_install_fdt(fdt_addr);
+		if (r)
+			return 1;
 		/* Execute the test */
 		r = efi_selftest(loaded_image_info_obj.handle, &systab);
 		efi_restore_gd();
diff --git a/lib/efi_selftest/Makefile b/lib/efi_selftest/Makefile
index 90246f7827..8160de0f89 100644
--- a/lib/efi_selftest/Makefile
+++ b/lib/efi_selftest/Makefile
@@ -17,6 +17,7 @@ efi_selftest_console.o \
 efi_selftest_devicepath.o \
 efi_selftest_events.o \
 efi_selftest_exitbootservices.o \
+efi_selftest_fdt.o \
 efi_selftest_gop.o \
 efi_selftest_manageprotocols.o \
 efi_selftest_snp.o \
diff --git a/lib/efi_selftest/efi_selftest_fdt.c b/lib/efi_selftest/efi_selftest_fdt.c
new file mode 100644
index 0000000000..9b3b83ba71
--- /dev/null
+++ b/lib/efi_selftest/efi_selftest_fdt.c
@@ -0,0 +1,182 @@
+/*
+ * efi_selftest_pos
+ *
+ * Copyright (c) 2018 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ *
+ * Test the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.
+ *
+ * The following services are tested:
+ * OutputString, TestString, SetAttribute.
+ */
+
+#include <efi_selftest.h>
+#include <libfdt.h>
+
+static struct efi_boot_services *boottime;
+static const char *fdt;
+
+/* This should be sufficent for */
+#define BUFFERSIZE 0x100000
+
+static efi_guid_t fdt_guid = EFI_FDT_GUID;
+
+/*
+ * Convert FDT value to host endianness.
+ *
+ * @val		FDT value
+ * @return	converted value
+ */
+static uint32_t f2h(fdt32_t val)
+{
+	char *buf = (char *)&val;
+	char i;
+
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	i = buf[0]; buf[0] = buf[3]; buf[3] = i;
+	i = buf[1]; buf[1] = buf[2]; buf[2] = i;
+#endif
+	return *(uint32_t *)buf;
+}
+
+/*
+ * Return the value of a property of the FDT root node.
+ *
+ * @name	name of the property
+ * @return	value of the property
+ */
+static char *get_property(const u16 *property)
+{
+	struct fdt_header *header = (struct fdt_header *)fdt;
+	const fdt32_t *pos;
+	const char *strings;
+
+	if (!header)
+		return NULL;
+
+	if (f2h(header->magic) != FDT_MAGIC) {
+		printf("Wrong magic\n");
+		return NULL;
+	}
+
+	pos = (fdt32_t *)(fdt + f2h(header->off_dt_struct));
+	strings = fdt + f2h(header->off_dt_strings);
+
+	for (;;) {
+		switch (f2h(pos[0])) {
+		case FDT_BEGIN_NODE: {
+			char *c = (char *)&pos[1];
+			size_t i;
+
+			for (i = 0; c[i]; ++i)
+				;
+			pos = &pos[2 + (i >> 2)];
+			break;
+		}
+		case FDT_PROP: {
+			struct fdt_property *prop = (struct fdt_property *)pos;
+			const char *label = &strings[f2h(prop->nameoff)];
+			efi_status_t ret;
+
+			/* Check if this the property to be returned */
+			if (!efi_st_strcmp_16_8(property, label)) {
+				char *str;
+				efi_uintn_t len = f2h(prop->len);
+
+				/*
+				 * The string may not be 0 terminated.
+				 * So we need a copy.
+				 */
+				ret = boottime->allocate_pool(
+					EFI_LOADER_DATA, len + 1,
+					(void **)&str);
+				if (ret != EFI_SUCCESS)
+					return NULL;
+				boottime->copy_mem(&str, &pos[3], len);
+				str[len] = 0;
+
+				return str;
+			}
+
+			pos = &pos[3 + ((f2h(prop->len) + 3) >> 2)];
+			break;
+		}
+		case FDT_NOP:
+			pos = &pos[1];
+			break;
+		default:
+			return NULL;
+		}
+	}
+}
+
+/*
+ * Setup unit test.
+ *
+ * @handle:	handle of the loaded image
+ * @systable:	system table
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int setup(const efi_handle_t img_handle,
+		 const struct efi_system_table *systable)
+{
+	efi_uintn_t i;
+
+	boottime = systable->boottime;
+
+	/* Find configuration tables */
+	for (i = 0; i < systable->nr_tables; ++i) {
+		if (!efi_st_memcmp(&systable->tables[i].guid, &fdt_guid,
+				   sizeof(efi_guid_t)))
+			fdt = systable->tables[i].table;
+	}
+	if (!fdt) {
+		efi_st_error("Missing device tree\n");
+		return EFI_ST_FAILURE;
+	}
+
+	return EFI_ST_SUCCESS;
+}
+
+/*
+ * Execute unit test.
+ *
+ * @return:	EFI_ST_SUCCESS for success
+ */
+static int execute(void)
+{
+	char *str;
+	efi_status_t ret;
+
+	str = get_property(L"compatible");
+	if (str) {
+		efi_st_printf("compatible: %s\n", str);
+		ret = boottime->free_pool(str);
+		if (ret != EFI_SUCCESS) {
+			efi_st_error("FreePool failed\n");
+			return EFI_ST_FAILURE;
+		}
+	} else {
+		efi_st_printf("Missing property 'compatible'\n");
+		return EFI_ST_FAILURE;
+	}
+	str = get_property(L"serial-number");
+	if (str) {
+		efi_st_printf("serial-number: %s\n", str);
+		ret = boottime->free_pool(str);
+		if (ret != EFI_SUCCESS) {
+			efi_st_error("FreePool failed\n");
+			return EFI_ST_FAILURE;
+		}
+	}
+
+	return EFI_ST_SUCCESS;
+}
+
+EFI_UNIT_TEST(fdt) = {
+	.name = "device tree",
+	.phase = EFI_EXECUTE_BEFORE_BOOTTIME_EXIT,
+	.setup = setup,
+	.execute = execute,
+};
diff --git a/test/py/tests/test_efi_selftest.py b/test/py/tests/test_efi_selftest.py
index 66b799bed6..f7eaf8d59d 100644
--- a/test/py/tests/test_efi_selftest.py
+++ b/test/py/tests/test_efi_selftest.py
@@ -24,6 +24,19 @@ def test_efi_selftest(u_boot_console):
 		raise Exception('Reset failed during the EFI selftest')
 	u_boot_console.restart_uboot();
 
+@pytest.mark.buildconfigspec('cmd_bootefi_selftest')
+def test_efi_selftest_device_tree(u_boot_console):
+	u_boot_console.run_command(cmd='setenv efi_selftest list')
+	output = u_boot_console.run_command('bootefi selftest')
+	assert '\'device tree\'' in output
+	u_boot_console.run_command(cmd='setenv efi_selftest device tree')
+	u_boot_console.run_command(cmd='setenv -f serial# Testing DT')
+	u_boot_console.run_command(cmd='bootefi selftest', wait_for_prompt=False)
+	m = u_boot_console.p.expect(['serial-number: Testing DT', 'U-Boot'])
+	if m != 0:
+		raise Exception('Reset failed in \'device tree\' test')
+	u_boot_console.restart_uboot();
+
 @pytest.mark.buildconfigspec('cmd_bootefi_selftest')
 def test_efi_selftest_watchdog_reboot(u_boot_console):
 	u_boot_console.run_command(cmd='setenv efi_selftest list')
-- 
2.14.2

