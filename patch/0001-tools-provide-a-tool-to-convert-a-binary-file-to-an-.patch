From 45de3e33288666241830f697ffbd1db1fe5d9270 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Mon, 18 Dec 2017 22:43:04 +0100
Subject: [PATCH 1/1] tools: provide a tool to convert a binary file to an
 include

For testing EFI disk management we need an in-memory image of
a disk.

The tool file2include converts a file to a C include. The file
is separated into strings of 8 bytes. Only the non-zero strings
are written to the include. The output format has been designed
to maintain readability.

 #define EFI_ST_DISK_IMG { 0x00010000, { \
  {0x000001b8, "\x94\x37\x69\xfc\x00\x00\x00\x00"}, /* .7i..... */ \
  {0x000001c0, "\x02\x00\x83\x02\x02\x00\x01\x00"}, /* ........ */ \
  {0x000001c8, "\x00\x00\x7f\x00\x00\x00\x00\x00"}, /* ........ */ \
  {0x000001f8, "\x00\x00\x00\x00\x00\x00\x55\xaa"}, /* ......U. */ \
 ...
  {0x00006000, "\x48\x65\x6c\x6c\x6f\x20\x77\x6f"}, /* Hello wo */ \
  {0x00006008, "\x72\x6c\x64\x21\x0a\x00\x00\x00"}, /* rld!.... */ \
  {0, NULL} } }

As the disk image needed for testing contains mostly zeroes a high
compression ratio can be attained.

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 MAINTAINERS          |   1 +
 tools/Makefile       |   3 ++
 tools/file2include.c | 106 +++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 110 insertions(+)
 create mode 100644 tools/file2include.c

diff --git a/MAINTAINERS b/MAINTAINERS
index e950267494..60960cb5de 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -290,6 +290,7 @@ F:	include/efi*
 F:	lib/efi*
 F:	test/py/tests/test_efi*
 F:	cmd/bootefi.c
+F:	tools/file2include.c
 
 FLATTENED DEVICE TREE
 M:	Simon Glass <sjg@chromium.org>
diff --git a/tools/Makefile b/tools/Makefile
index 4d32fe5910..e661532639 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -57,6 +57,8 @@ mkenvimage-objs := mkenvimage.o os_support.o lib/crc32.o
 hostprogs-y += dumpimage mkimage
 hostprogs-$(CONFIG_FIT_SIGNATURE) += fit_info fit_check_sign
 
+hostprogs-$(CONFIG_CMD_BOOTEFI_SELFTEST) += file2include
+
 FIT_SIG_OBJS-$(CONFIG_FIT_SIGNATURE) := common/image-sig.o
 
 # The following files are synced with upstream DTC.
@@ -118,6 +120,7 @@ dumpimage-objs := $(dumpimage-mkimage-objs) dumpimage.o
 mkimage-objs   := $(dumpimage-mkimage-objs) mkimage.o
 fit_info-objs   := $(dumpimage-mkimage-objs) fit_info.o
 fit_check_sign-objs   := $(dumpimage-mkimage-objs) fit_check_sign.o
+file2include-objs := file2include.o
 
 ifneq ($(CONFIG_MX23)$(CONFIG_MX28),)
 # Add CONFIG_MXS into host CFLAGS, so we can check whether or not register
diff --git a/tools/file2include.c b/tools/file2include.c
new file mode 100644
index 0000000000..7867ba0586
--- /dev/null
+++ b/tools/file2include.c
@@ -0,0 +1,106 @@
+/*
+ * Convert a file image to a C define
+ *
+ * Copyright (c) 2017 Heinrich Schuchardt <xypron.glpk@gmx.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ *
+ * For testing EFI disk management we need an in memory image of
+ * a disk.
+ *
+ * The tool file2include converts a file to a C include. The file
+ * is separated into strings of 8 bytes. Only the non-zero strings
+ * are written to the include. The output format has been designed
+ * to maintain readability.
+ *
+ * As the disk image needed for testing contains mostly zeroes a high
+ * compression ratio can be attained.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <malloc.h>
+
+/* Size of the blocks written to the compressed file */
+#define BLOCK_SIZE 8
+
+int main(int argc, char *argv[])
+{
+	FILE *file;
+	int ret;
+	unsigned char *buf;
+	size_t count, i, j;
+
+	/* Provide usage help */
+	if (argc != 2) {
+		printf("Usage:\n%s FILENAME\n", argv[0]);
+		return EXIT_FAILURE;
+	}
+	/* Open file */
+	file = fopen(argv[1], "r");
+	if (!file) {
+		perror("fopen");
+		return EXIT_FAILURE;
+	}
+	/* Get file length */
+	ret = fseek(file, 0, SEEK_END);
+	if (ret < 0) {
+		perror("fseek");
+		return EXIT_FAILURE;
+	}
+	count = ftell(file);
+	if (!count) {
+		fprintf(stderr, "File %s has length 0\n", argv[1]);
+		return EXIT_FAILURE;
+	}
+	rewind(file);
+	/* Read file */
+	buf = malloc(count);
+	if (!buf) {
+		perror("calloc");
+		return EXIT_FAILURE;
+	}
+	count = fread(buf, 1, count, file);
+
+	/* Generate output */
+	printf("/*\n");
+	printf(" *  Non-zero %u byte strings of a disk image\n", BLOCK_SIZE);
+	printf(" *\n");
+	printf(" *  Generated with tools/file2include\n");
+	printf(" *\n");
+	printf(" *  SPDX-License-Identifier:	GPL-2.0+\n");
+	printf(" */\n\n");
+	printf("#define EFI_ST_DISK_IMG { 0x%08zx, { \\\n", count);
+
+	for (i = 0; i < count; i += BLOCK_SIZE) {
+		int c = 0;
+
+		for (j = i; j < i + BLOCK_SIZE && j < count; ++j) {
+			if (buf[j])
+				c = 1;
+		}
+		if (!c)
+			continue;
+		printf("\t{0x%08zx, \"", i);
+		for (j = i; j < i + BLOCK_SIZE && j < count; ++j)
+			printf("\\x%02x", buf[j]);
+		printf("\"}, /* ");
+		for (j = i; j < i + BLOCK_SIZE && j < count; ++j) {
+			if (buf[j] >= 0x20 && buf[j] <= 0x7e)
+				printf("%c", buf[j]);
+			else
+				printf(".");
+		}
+		printf(" */ \\\n");
+	}
+	printf("\t{0, NULL} } }\n");
+
+	/* Release resources */
+	free(buf);
+	ret = fclose(file);
+	if (ret) {
+		perror("fclose");
+		return EXIT_FAILURE;
+	}
+	return EXIT_SUCCESS;
+}
-- 
2.14.2

