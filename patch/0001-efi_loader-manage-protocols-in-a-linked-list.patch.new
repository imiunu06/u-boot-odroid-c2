From e46b69ed9a31561df7a8164178f1a96bc3173f0d Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date: Sun, 22 Oct 2017 10:16:41 +0200
Subject: [PATCH 1/1] efi_loader: manage protocols in a linked list

Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
---
 include/efi_loader.h          |  6 +++--
 lib/efi_loader/efi_boottime.c | 51 ++++++++++++++++++++-----------------------
 2 files changed, 28 insertions(+), 29 deletions(-)

diff --git a/include/efi_loader.h b/include/efi_loader.h
index e1f0af3496..a73bbc1269 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -101,6 +101,8 @@ extern unsigned int __efi_runtime_rel_start, __efi_runtime_rel_stop;
  * interface (usually a struct with callback functions), this struct maps the
  * protocol GUID to the respective protocol interface */
 struct efi_handler {
+	/* Link to the list of protocols of a handle */
+	struct list_head link;
 	const efi_guid_t *guid;
 	void *protocol_interface;
 };
@@ -115,8 +117,8 @@ struct efi_handler {
 struct efi_object {
 	/* Every UEFI object is part of a global object list */
 	struct list_head link;
-	/* We support up to 16 "protocols" an object can be accessed through */
-	struct efi_handler protocols[16];
+	/* The list of protocols */
+	struct list_head protocols;
 	/* The object spawner can either use this for data or as identifier */
 	void *handle;
 };
diff --git a/lib/efi_loader/efi_boottime.c b/lib/efi_loader/efi_boottime.c
index 02ce7c8a5d..879dcd812d 100644
--- a/lib/efi_loader/efi_boottime.c
+++ b/lib/efi_loader/efi_boottime.c
@@ -715,18 +715,17 @@ efi_status_t efi_search_protocol(const void *handle,
 				 struct efi_handler **handler)
 {
 	struct efi_object *efiobj;
-	size_t i;
-	struct efi_handler *protocol;
+	struct list_head *lhandle;
 
 	if (!handle || !protocol_guid)
 		return EFI_INVALID_PARAMETER;
 	efiobj = efi_search_obj(handle);
 	if (!efiobj)
 		return EFI_INVALID_PARAMETER;
-	for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-		protocol = &efiobj->protocols[i];
-		if (!protocol->guid)
-			continue;
+	list_for_each(lhandle, &efiobj->protocols) {
+		struct efi_handler *protocol;
+
+		protocol = list_entry(lhandle, struct efi_handler, link);
 		if (!guidcmp(protocol->guid, protocol_guid)) {
 			if (handler)
 				*handler = protocol;
@@ -750,7 +749,6 @@ efi_status_t efi_add_protocol(const void *handle, const efi_guid_t *protocol,
 	struct efi_object *efiobj;
 	struct efi_handler *handler;
 	efi_status_t ret;
-	size_t i;
 
 	efiobj = efi_search_obj(handle);
 	if (!efiobj)
@@ -761,16 +759,10 @@ efi_status_t efi_add_protocol(const void *handle, const efi_guid_t *protocol,
 	handler = calloc(1, sizeof(struct efi_handler));
 	if (!handler)
 		return EFI_OUT_OF_RESOURCES;
-	/* Install protocol in first empty slot. */
-	for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-		handler = &efiobj->protocols[i];
-		if (handler->guid)
-			continue;
-		handler->guid = protocol;
-		handler->protocol_interface = protocol_interface;
-		return EFI_SUCCESS;
-	}
-	return EFI_OUT_OF_RESOURCES;
+	handler->guid = protocol;
+	handler->protocol_interface = protocol_interface;
+	list_add_tail(&handler->link, &efiobj->protocols);
+	return EFI_SUCCESS;
 }
 
 /*
@@ -790,10 +782,10 @@ efi_status_t efi_remove_protocol(const void *handle, const efi_guid_t *protocol,
 	ret = efi_search_protocol(handle, protocol, &handler);
 	if (ret != EFI_SUCCESS)
 		return ret;
-	if (handler->protocol_interface != protocol_interface)
-		return EFI_NOT_FOUND;
-	handler->guid = NULL;
-	handler->protocol_interface = NULL;
+	if (guidcmp(handler->guid, protocol))
+		return EFI_INVALID_PARAMETER;
+	list_del(&handler->link);
+	free(handler);
 	return EFI_SUCCESS;
 }
 
@@ -806,17 +798,22 @@ efi_status_t efi_remove_protocol(const void *handle, const efi_guid_t *protocol,
 efi_status_t efi_remove_all_protocols(const void *handle)
 {
 	struct efi_object *efiobj;
-	struct efi_handler *handler;
-	size_t i;
+	struct list_head *lhandle;
+	struct list_head *pos;
 
 	efiobj = efi_search_obj(handle);
 	if (!efiobj)
 		return EFI_INVALID_PARAMETER;
+	list_for_each_safe(lhandle, pos, &efiobj->protocols) {
+		struct efi_handler *protocol;
+		efi_status_t ret;
+
+		protocol = list_entry(lhandle, struct efi_handler, link);
 
-	for (i = 0; i < ARRAY_SIZE(efiobj->protocols); i++) {
-		handler = &efiobj->protocols[i];
-		handler->guid = NULL;
-		handler->protocol_interface = NULL;
+		ret = efi_remove_protocol(handle, protocol->guid,
+					  protocol->protocol_interface);
+		if (ret != EFI_SUCCESS)
+			return ret;
 	}
 	return EFI_SUCCESS;
 }
-- 
2.14.2

